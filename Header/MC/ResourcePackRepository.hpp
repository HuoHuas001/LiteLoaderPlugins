// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#include "../Global.h"
#include "Core.hpp"
#define EXTRA_INCLUDE_PART_RESOURCEPACKREPOSITORY
#include "Extra/ResourcePackRepositoryAPI.hpp"
#undef EXTRA_INCLUDE_PART_RESOURCEPACKREPOSITORY
class ResourcePackRepository {
#include "Extra/ResourcePackRepositoryAPI.hpp"
public:
    /*0*/ virtual ~ResourcePackRepository();
    /*1*/ virtual void getResourcePacksByPackId(std::vector<struct PackInstanceId> const&, std::vector<class PackInstance>&) const;
    /*2*/ virtual class ResourcePack* getResourcePackForPackId(struct PackIdVersion const&) const;
    /*3*/ virtual class ResourcePack* getResourcePackByUUID(class mce::UUID const&) const;
    /*4*/ virtual class ResourcePack* getResourcePackForPackIdOwned(struct PackIdVersion const&) const;
    /*5*/ virtual class ResourcePack* getResourcePackSatisfiesPackId(struct PackIdVersion const&, bool) const;
    /*6*/ virtual class ResourcePack* getResourcePackContainingModule(struct PackIdVersion const&) const;
    /*7*/ virtual class ResourcePack* getResourcePackInPath(class Core::Path const&) const;
    /*8*/ virtual bool isResourcePackLoaded(struct PackIdVersion const&, int /*enum enum PackOrigin*/ const&);
    /*9*/ virtual void __unk_vfn_0();
    /*10*/ virtual void __unk_vfn_1();
    /*11*/ virtual void __unk_vfn_2();
    /*12*/ virtual void __unk_vfn_3();
    /*13*/ virtual bool setServicePacks(std::vector<struct PackIdVersion>);
    /*14*/ virtual void addServicePacksToStack(class ResourcePackStack&) const;
    /*15*/ virtual void addCachedResourcePacks(class std::unordered_map<class ContentIdentity, std::string, struct std::hash<class ContentIdentity>, struct std::equal_to<class ContentIdentity>, class std::allocator<struct std::pair<class ContentIdentity const, std::string > > > const*);
    /*16*/ virtual void addWorldResourcePacks(class Core::Path const&);
    /*17*/ virtual void addPremiumWorldTemplateResourcePacks(class Core::Path const&, class ContentIdentity const&);
    /*18*/ virtual void removePacksLoadedFromCache();
    /*19*/ virtual void removePacksLoadedFromWorld();
    /*20*/ virtual class Core::PathBuffer<std::string > const getResourcePacksPath() const;
    /*21*/ virtual class Core::PathBuffer<std::string > const getBehaviorPacksPath() const;
    /*22*/ virtual class Core::PathBuffer<std::string > const getSkinPacksPath() const;
    /*23*/ virtual class Core::PathBuffer<std::string > const getDevelopmentResourcePacksPath() const;
    /*24*/ virtual class Core::PathBuffer<std::string > const getDevelopmentBehaviorPacksPath() const;
    /*25*/ virtual class Core::PathBuffer<std::string > const getDevelopmentSkinPacksPath() const;
    /*26*/ virtual class Core::PathBuffer<std::string > const getTreatmentPacksPath() const;
    /*27*/ virtual class Core::PathBuffer<std::string > const getKnownPacksPath(int /*enum enum KnownPackType*/) const;
    /*28*/ virtual class Core::PathBuffer<std::string > const getKnownValidPacksPath() const;
    /*29*/ virtual class Core::PathBuffer<std::string > const getKnownInvalidPacksPath() const;
    /*30*/ virtual void refreshPacks();
    /*31*/ virtual void requestReloadUserPacks();
    /*32*/ virtual void requestReloadDynamicPackagePacks();
    /*33*/ virtual class IContentKeyProvider const& getKeyProvider() const;
    /*34*/ virtual class PackManifestFactory& getPackManifestFactory();
    /*35*/ virtual class PackSettingsFactory& getPackSettingsFactory() const;
    /*36*/ virtual void __unk_vfn_4();
    /*37*/ virtual std::vector<class ResourcePack*> getPacksByResourceLocation(int /*enum enum PackOrigin*/) const;
    /*38*/ virtual std::vector<class ResourcePack*> getPacksByType(int /*enum enum PackType*/) const;
    /*39*/ virtual void addKnownPackFromImport(class PackManifest const&);
    /*40*/ virtual void addInvalidPack(class ResourceLocation const&, int /*enum enum PackType*/);
    /*41*/ virtual std::vector<class ResourceLocation> const& getInvalidPacks(int /*enum enum PackType*/) const;
    /*42*/ virtual std::vector<class ResourceLocation> getInvalidPacks(struct InvalidPacksFilterGroup const&) const;
    /*43*/ virtual void deletePack(class ResourceLocation const&);
    /*44*/ virtual void deletePackFiles(class ResourceLocation const&);
    /*45*/ virtual void postDeletePack(class ResourceLocation const&);
    /*46*/ virtual void untrackInvalidPack(class ResourceLocation const&);
    /*47*/ virtual void registerResourcePackRemovedCallback(void*, class std::function<void (class ResourcePack*)>);
    /*48*/ virtual void unregisterResourcePackRemovedCallback(void*);
    /*49*/ virtual bool isInitialized();
    /*
    inline class PackSourceReport const* getPackLoadingReport() const{
        class PackSourceReport const* (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getPackLoadingReport@ResourcePackRepository@@UEBAPEBVPackSourceReport@@XZ");
        return (this->*rv)();
    }
    inline class ResourcePack* getVanillaPack() const{
        class ResourcePack* (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getVanillaPack@ResourcePackRepository@@UEBAPEAVResourcePack@@XZ");
        return (this->*rv)();
    }
    inline class ResourcePack* getChemistryPack() const{
        class ResourcePack* (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getChemistryPack@ResourcePackRepository@@UEBAPEAVResourcePack@@XZ");
        return (this->*rv)();
    }
    inline void addCachedResourcePacks(class std::unordered_map<class ContentIdentity, std::string, struct std::hash<class ContentIdentity>, struct std::equal_to<class ContentIdentity>, class std::allocator<struct std::pair<class ContentIdentity const, std::string > > > const* a0){
        void (ResourcePackRepository::*rv)(class std::unordered_map<class ContentIdentity, std::string, struct std::hash<class ContentIdentity>, struct std::equal_to<class ContentIdentity>, class std::allocator<struct std::pair<class ContentIdentity const, std::string > > > const*);
        *((void**)&rv) = dlsym("?addCachedResourcePacks@ResourcePackRepository@@UEAAXPEBV?$unordered_map@VContentIdentity@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@VContentIdentity@@@3@U?$equal_to@VContentIdentity@@@3@V?$allocator@U?$pair@$$CBVContentIdentity@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@3@@std@@@Z");
        return (this->*rv)(std::forward<class std::unordered_map<class ContentIdentity, std::string, struct std::hash<class ContentIdentity>, struct std::equal_to<class ContentIdentity>, class std::allocator<struct std::pair<class ContentIdentity const, std::string > > > const*>(a0));
    }
    inline void addInvalidPack(class ResourceLocation const& a0, int \/*enum enum PackType*\/ a1){
        void (ResourcePackRepository::*rv)(class ResourceLocation const&, int \/*enum enum PackType*\/);
        *((void**)&rv) = dlsym("?addInvalidPack@ResourcePackRepository@@UEAAXAEBVResourceLocation@@W4PackType@@@Z");
        return (this->*rv)(std::forward<class ResourceLocation const&>(a0), std::forward<int \/*enum enum PackType*\/>(a1));
    }
    inline void addKnownPackFromImport(class PackManifest const& a0){
        void (ResourcePackRepository::*rv)(class PackManifest const&);
        *((void**)&rv) = dlsym("?addKnownPackFromImport@ResourcePackRepository@@UEAAXAEBVPackManifest@@@Z");
        return (this->*rv)(std::forward<class PackManifest const&>(a0));
    }
    inline void addPremiumWorldTemplateResourcePacks(class Core::Path const& a0, class ContentIdentity const& a1){
        void (ResourcePackRepository::*rv)(class Core::Path const&, class ContentIdentity const&);
        *((void**)&rv) = dlsym("?addPremiumWorldTemplateResourcePacks@ResourcePackRepository@@UEAAXAEBVPath@Core@@AEBVContentIdentity@@@Z");
        return (this->*rv)(std::forward<class Core::Path const&>(a0), std::forward<class ContentIdentity const&>(a1));
    }
    inline void addServicePacksToStack(class ResourcePackStack& a0) const{
        void (ResourcePackRepository::*rv)(class ResourcePackStack&) const;
        *((void**)&rv) = dlsym("?addServicePacksToStack@ResourcePackRepository@@UEBAXAEAVResourcePackStack@@@Z");
        return (this->*rv)(std::forward<class ResourcePackStack&>(a0));
    }
    inline void addWorldResourcePacks(class Core::Path const& a0){
        void (ResourcePackRepository::*rv)(class Core::Path const&);
        *((void**)&rv) = dlsym("?addWorldResourcePacks@ResourcePackRepository@@UEAAXAEBVPath@Core@@@Z");
        return (this->*rv)(std::forward<class Core::Path const&>(a0));
    }
    inline void deletePack(class ResourceLocation const& a0){
        void (ResourcePackRepository::*rv)(class ResourceLocation const&);
        *((void**)&rv) = dlsym("?deletePack@ResourcePackRepository@@UEAAXAEBVResourceLocation@@@Z");
        return (this->*rv)(std::forward<class ResourceLocation const&>(a0));
    }
    inline void deletePackFiles(class ResourceLocation const& a0){
        void (ResourcePackRepository::*rv)(class ResourceLocation const&);
        *((void**)&rv) = dlsym("?deletePackFiles@ResourcePackRepository@@UEAAXAEBVResourceLocation@@@Z");
        return (this->*rv)(std::forward<class ResourceLocation const&>(a0));
    }
    inline class Core::PathBuffer<std::string > const getBehaviorPacksPath() const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getBehaviorPacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline class ResourcePack* getChemistryServerPack() const{
        class ResourcePack* (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getChemistryServerPack@ResourcePackRepository@@UEBAPEAVResourcePack@@XZ");
        return (this->*rv)();
    }
    inline class Core::PathBuffer<std::string > const getDevelopmentBehaviorPacksPath() const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getDevelopmentBehaviorPacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline class Core::PathBuffer<std::string > const getDevelopmentResourcePacksPath() const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getDevelopmentResourcePacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline class Core::PathBuffer<std::string > const getDevelopmentSkinPacksPath() const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getDevelopmentSkinPacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline std::vector<class ResourceLocation> getInvalidPacks(struct InvalidPacksFilterGroup const& a0) const{
        std::vector<class ResourceLocation> (ResourcePackRepository::*rv)(struct InvalidPacksFilterGroup const&) const;
        *((void**)&rv) = dlsym("?getInvalidPacks@ResourcePackRepository@@UEBA?AV?$vector@VResourceLocation@@V?$allocator@VResourceLocation@@@std@@@std@@AEBUInvalidPacksFilterGroup@@@Z");
        return (this->*rv)(std::forward<struct InvalidPacksFilterGroup const&>(a0));
    }
    inline std::vector<class ResourceLocation> const& getInvalidPacks(int \/*enum enum PackType*\/ a0) const{
        std::vector<class ResourceLocation> const& (ResourcePackRepository::*rv)(int \/*enum enum PackType*\/) const;
        *((void**)&rv) = dlsym("?getInvalidPacks@ResourcePackRepository@@UEBAAEBV?$vector@VResourceLocation@@V?$allocator@VResourceLocation@@@std@@@std@@W4PackType@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum PackType*\/>(a0));
    }
    inline class IContentKeyProvider const& getKeyProvider() const{
        class IContentKeyProvider const& (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getKeyProvider@ResourcePackRepository@@UEBAAEBVIContentKeyProvider@@XZ");
        return (this->*rv)();
    }
    inline class Core::PathBuffer<std::string > const getKnownInvalidPacksPath() const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getKnownInvalidPacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline class Core::PathBuffer<std::string > const getKnownPacksPath(int \/*enum enum KnownPackType*\/ a0) const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)(int \/*enum enum KnownPackType*\/) const;
        *((void**)&rv) = dlsym("?getKnownPacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@W4KnownPackType@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum KnownPackType*\/>(a0));
    }
    inline class Core::PathBuffer<std::string > const getKnownValidPacksPath() const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getKnownValidPacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline class PackManifestFactory& getPackManifestFactory(){
        class PackManifestFactory& (ResourcePackRepository::*rv)();
        *((void**)&rv) = dlsym("?getPackManifestFactory@ResourcePackRepository@@UEAAAEAVPackManifestFactory@@XZ");
        return (this->*rv)();
    }
    inline class PackSettingsFactory& getPackSettingsFactory() const{
        class PackSettingsFactory& (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getPackSettingsFactory@ResourcePackRepository@@UEBAAEAVPackSettingsFactory@@XZ");
        return (this->*rv)();
    }
    inline class PackSourceFactory& getPackSourceFactory(){
        class PackSourceFactory& (ResourcePackRepository::*rv)();
        *((void**)&rv) = dlsym("?getPackSourceFactory@ResourcePackRepository@@UEAAAEAVPackSourceFactory@@XZ");
        return (this->*rv)();
    }
    inline std::vector<class ResourcePack*> getPacksByResourceLocation(int \/*enum enum PackOrigin*\/ a0) const{
        std::vector<class ResourcePack*> (ResourcePackRepository::*rv)(int \/*enum enum PackOrigin*\/) const;
        *((void**)&rv) = dlsym("?getPacksByResourceLocation@ResourcePackRepository@@UEBA?AV?$vector@PEAVResourcePack@@V?$allocator@PEAVResourcePack@@@std@@@std@@W4PackOrigin@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum PackOrigin*\/>(a0));
    }
    inline std::vector<class ResourcePack*> getPacksByType(int \/*enum enum PackType*\/ a0) const{
        std::vector<class ResourcePack*> (ResourcePackRepository::*rv)(int \/*enum enum PackType*\/) const;
        *((void**)&rv) = dlsym("?getPacksByType@ResourcePackRepository@@UEBA?AV?$vector@PEAVResourcePack@@V?$allocator@PEAVResourcePack@@@std@@@std@@W4PackType@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum PackType*\/>(a0));
    }
    inline class ResourcePack* getResourcePackByUUID(class mce::UUID const& a0) const{
        class ResourcePack* (ResourcePackRepository::*rv)(class mce::UUID const&) const;
        *((void**)&rv) = dlsym("?getResourcePackByUUID@ResourcePackRepository@@UEBAPEAVResourcePack@@AEBVUUID@mce@@@Z");
        return (this->*rv)(std::forward<class mce::UUID const&>(a0));
    }
    inline class ResourcePack* getResourcePackContainingModule(struct PackIdVersion const& a0) const{
        class ResourcePack* (ResourcePackRepository::*rv)(struct PackIdVersion const&) const;
        *((void**)&rv) = dlsym("?getResourcePackContainingModule@ResourcePackRepository@@UEBAPEAVResourcePack@@AEBUPackIdVersion@@@Z");
        return (this->*rv)(std::forward<struct PackIdVersion const&>(a0));
    }
    inline class ResourcePack* getResourcePackForPackId(struct PackIdVersion const& a0) const{
        class ResourcePack* (ResourcePackRepository::*rv)(struct PackIdVersion const&) const;
        *((void**)&rv) = dlsym("?getResourcePackForPackId@ResourcePackRepository@@UEBAPEAVResourcePack@@AEBUPackIdVersion@@@Z");
        return (this->*rv)(std::forward<struct PackIdVersion const&>(a0));
    }
    inline class ResourcePack* getResourcePackForPackIdOwned(struct PackIdVersion const& a0) const{
        class ResourcePack* (ResourcePackRepository::*rv)(struct PackIdVersion const&) const;
        *((void**)&rv) = dlsym("?getResourcePackForPackIdOwned@ResourcePackRepository@@UEBAPEAVResourcePack@@AEBUPackIdVersion@@@Z");
        return (this->*rv)(std::forward<struct PackIdVersion const&>(a0));
    }
    inline class ResourcePack* getResourcePackInPath(class Core::Path const& a0) const{
        class ResourcePack* (ResourcePackRepository::*rv)(class Core::Path const&) const;
        *((void**)&rv) = dlsym("?getResourcePackInPath@ResourcePackRepository@@UEBAPEAVResourcePack@@AEBVPath@Core@@@Z");
        return (this->*rv)(std::forward<class Core::Path const&>(a0));
    }
    inline class ResourcePack* getResourcePackSatisfiesPackId(struct PackIdVersion const& a0, bool a1) const{
        class ResourcePack* (ResourcePackRepository::*rv)(struct PackIdVersion const&, bool) const;
        *((void**)&rv) = dlsym("?getResourcePackSatisfiesPackId@ResourcePackRepository@@UEBAPEAVResourcePack@@AEBUPackIdVersion@@_N@Z");
        return (this->*rv)(std::forward<struct PackIdVersion const&>(a0), std::forward<bool>(a1));
    }
    inline void getResourcePacksByPackId(std::vector<struct PackInstanceId> const& a0, std::vector<class PackInstance>& a1) const{
        void (ResourcePackRepository::*rv)(std::vector<struct PackInstanceId> const&, std::vector<class PackInstance>&) const;
        *((void**)&rv) = dlsym("?getResourcePacksByPackId@ResourcePackRepository@@UEBAXAEBV?$vector@UPackInstanceId@@V?$allocator@UPackInstanceId@@@std@@@std@@AEAV?$vector@VPackInstance@@V?$allocator@VPackInstance@@@std@@@3@@Z");
        return (this->*rv)(std::forward<std::vector<struct PackInstanceId> const&>(a0), std::forward<std::vector<class PackInstance>&>(a1));
    }
    inline class Core::PathBuffer<std::string > const getResourcePacksPath() const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getResourcePacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline class Core::PathBuffer<std::string > const getSkinPacksPath() const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getSkinPacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline class Core::PathBuffer<std::string > const getTreatmentPacksPath() const{
        class Core::PathBuffer<std::string > const (ResourcePackRepository::*rv)() const;
        *((void**)&rv) = dlsym("?getTreatmentPacksPath@ResourcePackRepository@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline bool isInitialized(){
        bool (ResourcePackRepository::*rv)();
        *((void**)&rv) = dlsym("?isInitialized@ResourcePackRepository@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool isResourcePackLoaded(struct PackIdVersion const& a0, int \/*enum enum PackOrigin*\/ const& a1){
        bool (ResourcePackRepository::*rv)(struct PackIdVersion const&, int \/*enum enum PackOrigin*\/ const&);
        *((void**)&rv) = dlsym("?isResourcePackLoaded@ResourcePackRepository@@UEAA_NAEBUPackIdVersion@@AEBW4PackOrigin@@@Z");
        return (this->*rv)(std::forward<struct PackIdVersion const&>(a0), std::forward<int \/*enum enum PackOrigin*\/ const&>(a1));
    }
    inline void postDeletePack(class ResourceLocation const& a0){
        void (ResourcePackRepository::*rv)(class ResourceLocation const&);
        *((void**)&rv) = dlsym("?postDeletePack@ResourcePackRepository@@UEAAXAEBVResourceLocation@@@Z");
        return (this->*rv)(std::forward<class ResourceLocation const&>(a0));
    }
    inline void refreshPacks(){
        void (ResourcePackRepository::*rv)();
        *((void**)&rv) = dlsym("?refreshPacks@ResourcePackRepository@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void registerResourcePackRemovedCallback(void* a0, class std::function<void (class ResourcePack*)> a1){
        void (ResourcePackRepository::*rv)(void*, class std::function<void (class ResourcePack*)>);
        *((void**)&rv) = dlsym("?registerResourcePackRemovedCallback@ResourcePackRepository@@UEAAXPEAXV?$function@$$A6AXPEAVResourcePack@@@Z@std@@@Z");
        return (this->*rv)(std::forward<void*>(a0), std::forward<class std::function<void (class ResourcePack*)>>(a1));
    }
    inline void removePacksLoadedFromCache(){
        void (ResourcePackRepository::*rv)();
        *((void**)&rv) = dlsym("?removePacksLoadedFromCache@ResourcePackRepository@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void removePacksLoadedFromWorld(){
        void (ResourcePackRepository::*rv)();
        *((void**)&rv) = dlsym("?removePacksLoadedFromWorld@ResourcePackRepository@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void requestReloadDynamicPackagePacks(){
        void (ResourcePackRepository::*rv)();
        *((void**)&rv) = dlsym("?requestReloadDynamicPackagePacks@ResourcePackRepository@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void requestReloadUserPacks(){
        void (ResourcePackRepository::*rv)();
        *((void**)&rv) = dlsym("?requestReloadUserPacks@ResourcePackRepository@@UEAAXXZ");
        return (this->*rv)();
    }
    inline bool setServicePacks(std::vector<struct PackIdVersion> a0){
        bool (ResourcePackRepository::*rv)(std::vector<struct PackIdVersion>);
        *((void**)&rv) = dlsym("?setServicePacks@ResourcePackRepository@@UEAA_NV?$vector@UPackIdVersion@@V?$allocator@UPackIdVersion@@@std@@@std@@@Z");
        return (this->*rv)(std::forward<std::vector<struct PackIdVersion>>(a0));
    }
    inline void unregisterResourcePackRemovedCallback(void* a0){
        void (ResourcePackRepository::*rv)(void*);
        *((void**)&rv) = dlsym("?unregisterResourcePackRemovedCallback@ResourcePackRepository@@UEAAXPEAX@Z");
        return (this->*rv)(std::forward<void*>(a0));
    }
    inline void untrackInvalidPack(class ResourceLocation const& a0){
        void (ResourcePackRepository::*rv)(class ResourceLocation const&);
        *((void**)&rv) = dlsym("?untrackInvalidPack@ResourcePackRepository@@UEAAXAEBVResourceLocation@@@Z");
        return (this->*rv)(std::forward<class ResourceLocation const&>(a0));
    }
    */
    MCAPI static class mce::UUID const CHEMISTRY_PACK_UUID;
    MCAPI static class mce::UUID const CHEMISTRY_SERVER_PACK_UUID;

protected:

private:
    MCAPI bool _addResourcePackIfNotAlreadyAdded(class Pack&);
    MCAPI void _detectKnownPacksChange(struct ResourcePackRepository::KnownPackContainer&, struct ResourcePackRepository::KnownPackContainer const&, enum KnownPackType);
    MCAPI void _findVanillaPacks();
    MCAPI void _initialize();
    MCAPI void _initializeCachedPackSource();
    MCAPI void _initializePackSource();
    MCAPI void _initializeWorldPackSource();
    MCAPI void _loadLastKnownUserPacks(struct ResourcePackRepository::KnownPackContainer&, enum KnownPackType);
    MCAPI void _loadPacks(bool);
    MCAPI bool _packExists(class mce::UUID const&, class SemVersion const&, enum PackOrigin) const;
    MCAPI void _reloadDynamicPackagePacks();
    MCAPI void _reloadUserPacks();
    MCAPI bool _removePack(class ResourceLocation const&, bool);
    MCAPI void _saveKnownUserPacks(struct ResourcePackRepository::KnownPackContainer&, enum KnownPackType);
    MCAPI void _triggerRemoveResourcePackCallback(class ResourcePack*);
};