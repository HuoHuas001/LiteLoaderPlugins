// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#include "../Global.h"
#define EXTRA_INCLUDE_PART_CONTAINER
#include "Extra/ContainerAPI.hpp"
#undef EXTRA_INCLUDE_PART_CONTAINER
class Container {
#include "Extra/ContainerAPI.hpp"
public:
    /*0*/ virtual ~Container();
    /*1*/ virtual void init();
    /*2*/ virtual void serverInitItemStackIds(int, int, class std::function<void (int, class ItemStack const&)>) = 0;
    /*3*/ virtual void addContentChangeListener(class ContainerContentChangeListener*);
    /*4*/ virtual void removeContentChangeListener(class ContainerContentChangeListener*);
    /*5*/ virtual class ItemStack const& getItem(int) const = 0;
    /*6*/ virtual bool hasRoomForItem(class ItemStack const&);
    /*7*/ virtual void addItem(class ItemStack&);
    /*8*/ virtual bool addItemToFirstEmptySlot(class ItemStack const&);
    /*9*/ virtual void setItem(int, class ItemStack const&) = 0;
    /*10*/ virtual void setItemWithForceBalance(int, class ItemStack const&, bool);
    /*11*/ virtual void removeItem(int, int);
    /*12*/ virtual void removeAllItems();
    /*13*/ virtual void dropContents(class BlockSource&, class Vec3 const&, bool);
    /*14*/ virtual void __unk_vfn_0() = 0;
    /*15*/ virtual int getMaxStackSize() const = 0;
    /*16*/ virtual void startOpen(class Player&) = 0;
    /*17*/ virtual void stopOpen(class Player&) = 0;
    /*18*/ virtual std::vector<class ItemStack> getSlotCopies() const;
    /*19*/ virtual std::vector<class ItemStack const*> const getSlots() const;
    /*20*/ virtual int getItemCount(class ItemStack const&) const;
    /*21*/ virtual int findFirstSlotForItem(class ItemStack const&) const;
    /*22*/ virtual void __unk_vfn_1();
    /*23*/ virtual void __unk_vfn_2();
    /*24*/ virtual void setContainerChanged(int);
    /*25*/ virtual void setContainerMoved();
    /*26*/ virtual void setCustomName(std::string const&);
    /*27*/ virtual bool hasCustomName() const;
    /*28*/ virtual void readAdditionalSaveData(class CompoundTag const&);
    /*29*/ virtual void addAdditionalSaveData(class CompoundTag&);
    /*30*/ virtual void createTransactionContext(class std::function<void (class Container&, int, class ItemStack const&, class ItemStack const&)>, class std::function<void (void)>);
    /*31*/ virtual void __unk_vfn_3();
    /*32*/ virtual bool isEmpty() const;
    /*
    inline void init(){
        void (Container::*rv)();
        *((void**)&rv) = dlsym("?init@Container@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void initializeContainerContents(class BlockSource& a0){
        void (Container::*rv)(class BlockSource&);
        *((void**)&rv) = dlsym("?initializeContainerContents@Container@@UEAAXAEAVBlockSource@@@Z");
        return (this->*rv)(std::forward<class BlockSource&>(a0));
    }
    inline bool canPushInItem(class BlockSource& a0, int a1, int a2, class ItemInstance const& a3) const{
        bool (Container::*rv)(class BlockSource&, int, int, class ItemInstance const&) const;
        *((void**)&rv) = dlsym("?canPushInItem@Container@@UEBA_NAEAVBlockSource@@HHAEBVItemInstance@@@Z");
        return (this->*rv)(std::forward<class BlockSource&>(a0), std::forward<int>(a1), std::forward<int>(a2), std::forward<class ItemInstance const&>(a3));
    }
    inline bool canPullOutItem(class BlockSource& a0, int a1, int a2, class ItemInstance const& a3) const{
        bool (Container::*rv)(class BlockSource&, int, int, class ItemInstance const&) const;
        *((void**)&rv) = dlsym("?canPullOutItem@Container@@UEBA_NAEAVBlockSource@@HHAEBVItemInstance@@@Z");
        return (this->*rv)(std::forward<class BlockSource&>(a0), std::forward<int>(a1), std::forward<int>(a2), std::forward<class ItemInstance const&>(a3));
    }
    inline void addAdditionalSaveData(class CompoundTag& a0){
        void (Container::*rv)(class CompoundTag&);
        *((void**)&rv) = dlsym("?addAdditionalSaveData@Container@@UEAAXAEAVCompoundTag@@@Z");
        return (this->*rv)(std::forward<class CompoundTag&>(a0));
    }
    inline void addContentChangeListener(class ContainerContentChangeListener* a0){
        void (Container::*rv)(class ContainerContentChangeListener*);
        *((void**)&rv) = dlsym("?addContentChangeListener@Container@@UEAAXPEAVContainerContentChangeListener@@@Z");
        return (this->*rv)(std::forward<class ContainerContentChangeListener*>(a0));
    }
    inline void addItem(class ItemStack& a0){
        void (Container::*rv)(class ItemStack&);
        *((void**)&rv) = dlsym("?addItem@Container@@UEAAXAEAVItemStack@@@Z");
        return (this->*rv)(std::forward<class ItemStack&>(a0));
    }
    inline bool addItemToFirstEmptySlot(class ItemStack const& a0){
        bool (Container::*rv)(class ItemStack const&);
        *((void**)&rv) = dlsym("?addItemToFirstEmptySlot@Container@@UEAA_NAEBVItemStack@@@Z");
        return (this->*rv)(std::forward<class ItemStack const&>(a0));
    }
    inline void createTransactionContext(class std::function<void (class Container&, int, class ItemStack const&, class ItemStack const&)> a0, class std::function<void (void)> a1){
        void (Container::*rv)(class std::function<void (class Container&, int, class ItemStack const&, class ItemStack const&)>, class std::function<void (void)>);
        *((void**)&rv) = dlsym("?createTransactionContext@Container@@UEAAXV?$function@$$A6AXAEAVContainer@@HAEBVItemStack@@1@Z@std@@V?$function@$$A6AXXZ@3@@Z");
        return (this->*rv)(std::forward<class std::function<void (class Container&, int, class ItemStack const&, class ItemStack const&)>>(a0), std::forward<class std::function<void (void)>>(a1));
    }
    inline void dropContents(class BlockSource& a0, class Vec3 const& a1, bool a2){
        void (Container::*rv)(class BlockSource&, class Vec3 const&, bool);
        *((void**)&rv) = dlsym("?dropContents@Container@@UEAAXAEAVBlockSource@@AEBVVec3@@_N@Z");
        return (this->*rv)(std::forward<class BlockSource&>(a0), std::forward<class Vec3 const&>(a1), std::forward<bool>(a2));
    }
    inline int findFirstSlotForItem(class ItemStack const& a0) const{
        int (Container::*rv)(class ItemStack const&) const;
        *((void**)&rv) = dlsym("?findFirstSlotForItem@Container@@UEBAHAEBVItemStack@@@Z");
        return (this->*rv)(std::forward<class ItemStack const&>(a0));
    }
    inline int getItemCount(class ItemStack const& a0) const{
        int (Container::*rv)(class ItemStack const&) const;
        *((void**)&rv) = dlsym("?getItemCount@Container@@UEBAHAEBVItemStack@@@Z");
        return (this->*rv)(std::forward<class ItemStack const&>(a0));
    }
    inline std::vector<class ItemStack> getSlotCopies() const{
        std::vector<class ItemStack> (Container::*rv)() const;
        *((void**)&rv) = dlsym("?getSlotCopies@Container@@UEBA?AV?$vector@VItemStack@@V?$allocator@VItemStack@@@std@@@std@@XZ");
        return (this->*rv)();
    }
    inline std::vector<class ItemStack const*> const getSlots() const{
        std::vector<class ItemStack const*> const (Container::*rv)() const;
        *((void**)&rv) = dlsym("?getSlots@Container@@UEBA?BV?$vector@PEBVItemStack@@V?$allocator@PEBVItemStack@@@std@@@std@@XZ");
        return (this->*rv)();
    }
    inline bool hasCustomName() const{
        bool (Container::*rv)() const;
        *((void**)&rv) = dlsym("?hasCustomName@Container@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool hasRoomForItem(class ItemStack const& a0){
        bool (Container::*rv)(class ItemStack const&);
        *((void**)&rv) = dlsym("?hasRoomForItem@Container@@UEAA_NAEBVItemStack@@@Z");
        return (this->*rv)(std::forward<class ItemStack const&>(a0));
    }
    inline bool isEmpty() const{
        bool (Container::*rv)() const;
        *((void**)&rv) = dlsym("?isEmpty@Container@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline void readAdditionalSaveData(class CompoundTag const& a0){
        void (Container::*rv)(class CompoundTag const&);
        *((void**)&rv) = dlsym("?readAdditionalSaveData@Container@@UEAAXAEBVCompoundTag@@@Z");
        return (this->*rv)(std::forward<class CompoundTag const&>(a0));
    }
    inline void removeAllItems(){
        void (Container::*rv)();
        *((void**)&rv) = dlsym("?removeAllItems@Container@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void removeContentChangeListener(class ContainerContentChangeListener* a0){
        void (Container::*rv)(class ContainerContentChangeListener*);
        *((void**)&rv) = dlsym("?removeContentChangeListener@Container@@UEAAXPEAVContainerContentChangeListener@@@Z");
        return (this->*rv)(std::forward<class ContainerContentChangeListener*>(a0));
    }
    inline void removeItem(int a0, int a1){
        void (Container::*rv)(int, int);
        *((void**)&rv) = dlsym("?removeItem@Container@@UEAAXHH@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<int>(a1));
    }
    inline void setContainerChanged(int a0){
        void (Container::*rv)(int);
        *((void**)&rv) = dlsym("?setContainerChanged@Container@@UEAAXH@Z");
        return (this->*rv)(std::forward<int>(a0));
    }
    inline void setContainerMoved(){
        void (Container::*rv)();
        *((void**)&rv) = dlsym("?setContainerMoved@Container@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void setCustomName(std::string const& a0){
        void (Container::*rv)(std::string const&);
        *((void**)&rv) = dlsym("?setCustomName@Container@@UEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline void setItemWithForceBalance(int a0, class ItemStack const& a1, bool a2){
        void (Container::*rv)(int, class ItemStack const&, bool);
        *((void**)&rv) = dlsym("?setItemWithForceBalance@Container@@UEAAXHAEBVItemStack@@_N@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<class ItemStack const&>(a1), std::forward<bool>(a2));
    }
    */
    MCAPI enum ContainerType getContainerType() const;
    MCAPI enum ContainerType getGameplayContainerType() const;
    MCAPI int getItemCount(class std::function<bool (class ItemStack const&)>);
    MCAPI int getRedstoneSignalFromContainer(class BlockSource&);
    MCAPI class TypedRuntimeId<struct ContainerRuntimeIdTag, unsigned int, 0> const& getRuntimeId() const;
    MCAPI void initRuntimeId();
    MCAPI void serverInitItemStackIdsAll(class std::function<void (int, class ItemStack const&)>);
    MCAPI void setGameplayContainerType(enum ContainerType);
    MCAPI void triggerTransactionChange(int, class ItemStack const&, class ItemStack const&);
    MCAPI static enum ContainerType getContainerTypeId(std::string const&);
    MCAPI static std::string const& getContainerTypeName(enum ContainerType);

protected:
    MCAPI void _serverInitId(int, class ItemStack&, class std::function<void (int, class ItemStack const&)>);
    MCAPI static class BidirectionalUnorderedMap<enum ContainerType, std::string > const containerTypeMap;

private:
};