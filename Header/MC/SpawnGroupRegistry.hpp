// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#include "../Global.h"
#define EXTRA_INCLUDE_PART_SPAWNGROUPREGISTRY
#include "Extra/SpawnGroupRegistryAPI.hpp"
#undef EXTRA_INCLUDE_PART_SPAWNGROUPREGISTRY
class SpawnGroupRegistry {
#include "Extra/SpawnGroupRegistryAPI.hpp"
public:
    /*0*/ virtual ~SpawnGroupRegistry();
    /*1*/ virtual std::string const& getRootKey();
    /*2*/ virtual std::string const& getFileType();
    /*3*/ virtual void __unk_vfn_0();
    /*4*/ virtual void readResourceFiles(class ResourcePackManager&, class std::unordered_map<std::string, std::string, struct std::hash<std::string >, struct std::equal_to<std::string >, class std::allocator<struct std::pair<std::string const, std::string > > >&);
    /*
    inline bool processPopulationControl(std::string const& a0, class Json::Value& a1){
        bool (SpawnGroupRegistry::*rv)(std::string const&, class Json::Value&);
        *((void**)&rv) = dlsym("?processPopulationControl@SpawnGroupRegistry@@MEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@Json@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<class Json::Value&>(a1));
    }
    inline std::string const& getFileType(){
        std::string const& (SpawnGroupRegistry::*rv)();
        *((void**)&rv) = dlsym("?getFileType@SpawnGroupRegistry@@MEAAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ");
        return (this->*rv)();
    }
    inline std::string const& getRootKey(){
        std::string const& (SpawnGroupRegistry::*rv)();
        *((void**)&rv) = dlsym("?getRootKey@SpawnGroupRegistry@@MEAAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ");
        return (this->*rv)();
    }
    inline void readResourceFiles(class ResourcePackManager& a0, class std::unordered_map<std::string, std::string, struct std::hash<std::string >, struct std::equal_to<std::string >, class std::allocator<struct std::pair<std::string const, std::string > > >& a1){
        void (SpawnGroupRegistry::*rv)(class ResourcePackManager&, class std::unordered_map<std::string, std::string, struct std::hash<std::string >, struct std::equal_to<std::string >, class std::allocator<struct std::pair<std::string const, std::string > > >&);
        *((void**)&rv) = dlsym("?readResourceFiles@SpawnGroupRegistry@@MEAAXAEAVResourcePackManager@@AEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@@Z");
        return (this->*rv)(std::forward<class ResourcePackManager&>(a0), std::forward<class std::unordered_map<std::string, std::string, struct std::hash<std::string >, struct std::equal_to<std::string >, class std::allocator<struct std::pair<std::string const, std::string > > >&>(a1));
    }
    */
    MCAPI class SpawnGroupData const* getSpawnGroup(std::string const&) const;

protected:

private:
};