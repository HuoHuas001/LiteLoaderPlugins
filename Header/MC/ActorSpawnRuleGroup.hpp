// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#include "../Global.h"
#include "Json.hpp"
#define EXTRA_INCLUDE_PART_ACTORSPAWNRULEGROUP
#include "Extra/ActorSpawnRuleGroupAPI.hpp"
#undef EXTRA_INCLUDE_PART_ACTORSPAWNRULEGROUP
class ActorSpawnRuleGroup {
#include "Extra/ActorSpawnRuleGroupAPI.hpp"
public:
    /*0*/ virtual ~ActorSpawnRuleGroup();
    /*1*/ virtual std::string const& getRootKey();
    /*2*/ virtual std::string const& getFileType();
    /*3*/ virtual bool processPopulationControl(std::string const&, class Json::Value&);
    /*4*/ virtual void readResourceFiles(class ResourcePackManager&, class std::unordered_map<std::string, std::string, struct std::hash<std::string >, struct std::equal_to<std::string >, class std::allocator<struct std::pair<std::string const, std::string > > >&);
    /*
    inline std::string const& getFileType(){
        std::string const& (ActorSpawnRuleGroup::*rv)();
        *((void**)&rv) = dlsym("?getFileType@ActorSpawnRuleGroup@@MEAAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ");
        return (this->*rv)();
    }
    inline std::string const& getRootKey(){
        std::string const& (ActorSpawnRuleGroup::*rv)();
        *((void**)&rv) = dlsym("?getRootKey@ActorSpawnRuleGroup@@MEAAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ");
        return (this->*rv)();
    }
    inline bool processPopulationControl(std::string const& a0, class Json::Value& a1){
        bool (ActorSpawnRuleGroup::*rv)(std::string const&, class Json::Value&);
        *((void**)&rv) = dlsym("?processPopulationControl@ActorSpawnRuleGroup@@MEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@Json@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<class Json::Value&>(a1));
    }
    inline void readResourceFiles(class ResourcePackManager& a0, class std::unordered_map<std::string, std::string, struct std::hash<std::string >, struct std::equal_to<std::string >, class std::allocator<struct std::pair<std::string const, std::string > > >& a1){
        void (ActorSpawnRuleGroup::*rv)(class ResourcePackManager&, class std::unordered_map<std::string, std::string, struct std::hash<std::string >, struct std::equal_to<std::string >, class std::allocator<struct std::pair<std::string const, std::string > > >&);
        *((void**)&rv) = dlsym("?readResourceFiles@ActorSpawnRuleGroup@@MEAAXAEAVResourcePackManager@@AEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@@Z");
        return (this->*rv)(std::forward<class ResourcePackManager&>(a0), std::forward<class std::unordered_map<std::string, std::string, struct std::hash<std::string >, struct std::equal_to<std::string >, class std::allocator<struct std::pair<std::string const, std::string > > >&>(a1));
    }
    */
    MCAPI int getActorSpawnPool(struct ActorDefinitionIdentifier const&) const;
    MCAPI int getDelayEnd(std::string) const;
    MCAPI void offSetDelayByCurrentTick(struct Tick const&);
    MCAPI void resetDelayEnd(class MobSpawnRules, unsigned __int64, class Random&);

protected:

private:
};