// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#include "../Global.h"
#include "Core.hpp"
#define EXTRA_INCLUDE_PART_EXTERNALFILELEVELSTORAGESOURCE
#include "Extra/ExternalFileLevelStorageSourceAPI.hpp"
#undef EXTRA_INCLUDE_PART_EXTERNALFILELEVELSTORAGESOURCE
class ExternalFileLevelStorageSource {
#include "Extra/ExternalFileLevelStorageSourceAPI.hpp"
public:
    /*0*/ virtual ~ExternalFileLevelStorageSource();
    /*1*/ virtual std::string const& getName() const;
    /*2*/ virtual class LevelData getLevelData(std::string const&) const;
    /*3*/ virtual class Core::Result getLevelData(std::string const&, class LevelData&) const;
    /*4*/ virtual void saveLevelData(std::string const&, class LevelData const&);
    /*5*/ virtual void getLevelList(std::vector<class Core::PathBuffer<std::string >>&);
    /*6*/ virtual std::unique_ptr<class LevelStorage> createLevelStorage(class Scheduler&, std::string const&, class ContentIdentity const&, class IContentKeyProvider const&, class std::chrono::duration<__int64, struct std::ratio<1, 1000000000> > const&, std::unique_ptr<class LevelStorageEventing>);
    /*7*/ virtual std::unique_ptr<class LevelLooseFileStorage> createLevelLooseStorage(std::string const&, class ContentIdentity const&, class IContentKeyProvider const&);
    /*8*/ virtual void __unk_vfn_0();
    /*9*/ virtual void deleteLevel(std::string const&);
    /*10*/ virtual bool renameLevel(std::string const&, std::string const&);
    /*11*/ virtual void renameLevel(class LevelData&, class Core::Path const&, std::string const&);
    /*12*/ virtual bool createBackupCopyOfWorld(std::string const&, std::string const&, std::string const&);
    /*13*/ virtual void __unk_vfn_1();
    /*14*/ virtual void __unk_vfn_2();
    /*15*/ virtual void __unk_vfn_3();
    /*16*/ virtual bool isLevelMarkedForSync(class Core::Path const&) const;
    /*17*/ virtual bool isLevelPartiallyCopied(class Core::Path const&) const;
    /*18*/ virtual class Core::PathBuffer<std::string > getLevelDatFoundPath(class Core::Path const&) const;
    /*19*/ virtual class Core::PathBuffer<std::string > const getBasePath() const;
    /*20*/ virtual class Core::PathBuffer<std::string > const getPathToLevel(std::string const&) const;
    /*21*/ virtual class Core::PathBuffer<std::string > const getPathToLevelInfo(std::string const&, bool) const;
    /*
    inline bool requiresConversion(std::string const& a0){
        bool (ExternalFileLevelStorageSource::*rv)(std::string const&);
        *((void**)&rv) = dlsym("?requiresConversion@ExternalFileLevelStorageSource@@UEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline bool isConvertible(std::string const& a0){
        bool (ExternalFileLevelStorageSource::*rv)(std::string const&);
        *((void**)&rv) = dlsym("?isConvertible@ExternalFileLevelStorageSource@@UEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline bool isBetaRetailLevel(std::string const& a0) const{
        bool (ExternalFileLevelStorageSource::*rv)(std::string const&) const;
        *((void**)&rv) = dlsym("?isBetaRetailLevel@ExternalFileLevelStorageSource@@UEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline bool convertLevel(std::string const& a0, class ProgressListener* a1){
        bool (ExternalFileLevelStorageSource::*rv)(std::string const&, class ProgressListener*);
        *((void**)&rv) = dlsym("?convertLevel@ExternalFileLevelStorageSource@@UEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVProgressListener@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<class ProgressListener*>(a1));
    }
    inline bool isNewLevelIdAcceptable(std::string const& a0){
        bool (ExternalFileLevelStorageSource::*rv)(std::string const&);
        *((void**)&rv) = dlsym("?isNewLevelIdAcceptable@ExternalFileLevelStorageSource@@UEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline bool createBackupCopyOfWorld(std::string const& a0, std::string const& a1, std::string const& a2){
        bool (ExternalFileLevelStorageSource::*rv)(std::string const&, std::string const&, std::string const&);
        *((void**)&rv) = dlsym("?createBackupCopyOfWorld@ExternalFileLevelStorageSource@@UEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<std::string const&>(a1), std::forward<std::string const&>(a2));
    }
    inline std::unique_ptr<class LevelLooseFileStorage> createLevelLooseStorage(std::string const& a0, class ContentIdentity const& a1, class IContentKeyProvider const& a2){
        std::unique_ptr<class LevelLooseFileStorage> (ExternalFileLevelStorageSource::*rv)(std::string const&, class ContentIdentity const&, class IContentKeyProvider const&);
        *((void**)&rv) = dlsym("?createLevelLooseStorage@ExternalFileLevelStorageSource@@UEAA?AV?$unique_ptr@VLevelLooseFileStorage@@U?$default_delete@VLevelLooseFileStorage@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEBVContentIdentity@@AEBVIContentKeyProvider@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<class ContentIdentity const&>(a1), std::forward<class IContentKeyProvider const&>(a2));
    }
    inline std::unique_ptr<class LevelStorage> createLevelStorage(class Scheduler& a0, std::string const& a1, class ContentIdentity const& a2, class IContentKeyProvider const& a3, class std::chrono::duration<__int64, struct std::ratio<1, 1000000000> > const& a4, std::unique_ptr<class LevelStorageEventing> a5){
        std::unique_ptr<class LevelStorage> (ExternalFileLevelStorageSource::*rv)(class Scheduler&, std::string const&, class ContentIdentity const&, class IContentKeyProvider const&, class std::chrono::duration<__int64, struct std::ratio<1, 1000000000> > const&, std::unique_ptr<class LevelStorageEventing>);
        *((void**)&rv) = dlsym("?createLevelStorage@ExternalFileLevelStorageSource@@UEAA?AV?$unique_ptr@VLevelStorage@@U?$default_delete@VLevelStorage@@@std@@@std@@AEAVScheduler@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEBVContentIdentity@@AEBVIContentKeyProvider@@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@3@V?$unique_ptr@VLevelStorageEventing@@U?$default_delete@VLevelStorageEventing@@@std@@@3@@Z");
        return (this->*rv)(std::forward<class Scheduler&>(a0), std::forward<std::string const&>(a1), std::forward<class ContentIdentity const&>(a2), std::forward<class IContentKeyProvider const&>(a3), std::forward<class std::chrono::duration<__int64, struct std::ratio<1, 1000000000> > const&>(a4), std::forward<std::unique_ptr<class LevelStorageEventing>>(a5));
    }
    inline void deleteLevel(std::string const& a0){
        void (ExternalFileLevelStorageSource::*rv)(std::string const&);
        *((void**)&rv) = dlsym("?deleteLevel@ExternalFileLevelStorageSource@@UEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline class Core::PathBuffer<std::string > const getBasePath() const{
        class Core::PathBuffer<std::string > const (ExternalFileLevelStorageSource::*rv)() const;
        *((void**)&rv) = dlsym("?getBasePath@ExternalFileLevelStorageSource@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@XZ");
        return (this->*rv)();
    }
    inline class Core::PathBuffer<std::string > getLevelDatFoundPath(class Core::Path const& a0) const{
        class Core::PathBuffer<std::string > (ExternalFileLevelStorageSource::*rv)(class Core::Path const&) const;
        *((void**)&rv) = dlsym("?getLevelDatFoundPath@ExternalFileLevelStorageSource@@UEBA?AV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@AEBVPath@3@@Z");
        return (this->*rv)(std::forward<class Core::Path const&>(a0));
    }
    inline class LevelData getLevelData(std::string const& a0) const{
        class LevelData (ExternalFileLevelStorageSource::*rv)(std::string const&) const;
        *((void**)&rv) = dlsym("?getLevelData@ExternalFileLevelStorageSource@@UEBA?AVLevelData@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline class Core::Result getLevelData(std::string const& a0, class LevelData& a1) const{
        class Core::Result (ExternalFileLevelStorageSource::*rv)(std::string const&, class LevelData&) const;
        *((void**)&rv) = dlsym("?getLevelData@ExternalFileLevelStorageSource@@UEBA?AVResult@Core@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVLevelData@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<class LevelData&>(a1));
    }
    inline void getLevelList(std::vector<class Core::PathBuffer<std::string >>& a0){
        void (ExternalFileLevelStorageSource::*rv)(std::vector<class Core::PathBuffer<std::string >>&);
        *((void**)&rv) = dlsym("?getLevelList@ExternalFileLevelStorageSource@@UEAAXAEAV?$vector@V?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@V?$allocator@V?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@@std@@@std@@@Z");
        return (this->*rv)(std::forward<std::vector<class Core::PathBuffer<std::string >>&>(a0));
    }
    inline std::string const& getName() const{
        std::string const& (ExternalFileLevelStorageSource::*rv)() const;
        *((void**)&rv) = dlsym("?getName@ExternalFileLevelStorageSource@@UEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ");
        return (this->*rv)();
    }
    inline class Core::PathBuffer<std::string > const getPathToLevel(std::string const& a0) const{
        class Core::PathBuffer<std::string > const (ExternalFileLevelStorageSource::*rv)(std::string const&) const;
        *((void**)&rv) = dlsym("?getPathToLevel@ExternalFileLevelStorageSource@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline class Core::PathBuffer<std::string > const getPathToLevelInfo(std::string const& a0, bool a1) const{
        class Core::PathBuffer<std::string > const (ExternalFileLevelStorageSource::*rv)(std::string const&, bool) const;
        *((void**)&rv) = dlsym("?getPathToLevelInfo@ExternalFileLevelStorageSource@@UEBA?BV?$PathBuffer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Core@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<bool>(a1));
    }
    inline bool isLevelMarkedForSync(class Core::Path const& a0) const{
        bool (ExternalFileLevelStorageSource::*rv)(class Core::Path const&) const;
        *((void**)&rv) = dlsym("?isLevelMarkedForSync@ExternalFileLevelStorageSource@@UEBA_NAEBVPath@Core@@@Z");
        return (this->*rv)(std::forward<class Core::Path const&>(a0));
    }
    inline bool isLevelPartiallyCopied(class Core::Path const& a0) const{
        bool (ExternalFileLevelStorageSource::*rv)(class Core::Path const&) const;
        *((void**)&rv) = dlsym("?isLevelPartiallyCopied@ExternalFileLevelStorageSource@@UEBA_NAEBVPath@Core@@@Z");
        return (this->*rv)(std::forward<class Core::Path const&>(a0));
    }
    inline void renameLevel(class LevelData& a0, class Core::Path const& a1, std::string const& a2){
        void (ExternalFileLevelStorageSource::*rv)(class LevelData&, class Core::Path const&, std::string const&);
        *((void**)&rv) = dlsym("?renameLevel@ExternalFileLevelStorageSource@@UEAAXAEAVLevelData@@AEBVPath@Core@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<class LevelData&>(a0), std::forward<class Core::Path const&>(a1), std::forward<std::string const&>(a2));
    }
    inline bool renameLevel(std::string const& a0, std::string const& a1){
        bool (ExternalFileLevelStorageSource::*rv)(std::string const&, std::string const&);
        *((void**)&rv) = dlsym("?renameLevel@ExternalFileLevelStorageSource@@UEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<std::string const&>(a1));
    }
    inline void saveLevelData(std::string const& a0, class LevelData const& a1){
        void (ExternalFileLevelStorageSource::*rv)(std::string const&, class LevelData const&);
        *((void**)&rv) = dlsym("?saveLevelData@ExternalFileLevelStorageSource@@UEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVLevelData@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<class LevelData const&>(a1));
    }
    */

protected:

private:
};