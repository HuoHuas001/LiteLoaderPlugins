// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#include "../Global.h"
#include "VehicleUtils.hpp"
#define EXTRA_INCLUDE_PART_ACTOR
#include "Extra/ActorAPI.hpp"
#undef EXTRA_INCLUDE_PART_ACTOR
class Actor {
#include "Extra/ActorAPI.hpp"
public:
    /*0*/ virtual bool hasComponent(class HashedString const&) const;
    /*1*/ virtual class Mob* getLastHurtByMob();
    /*2*/ virtual void setLastHurtByMob(class Mob*);
    /*3*/ virtual class Player* getLastHurtByPlayer();
    /*4*/ virtual void setLastHurtByPlayer(class Player*);
    /*5*/ virtual class Mob* getLastHurtMob();
    /*6*/ virtual void setLastHurtMob(class Actor*);
    /*7*/ virtual void outOfWorld();
    /*8*/ virtual void reloadHardcoded(int /*enum enum Actor::InitializationMethod*/, class VariantParameterList const&);
    /*9*/ virtual void reloadHardcodedClient(int /*enum enum Actor::InitializationMethod*/, class VariantParameterList const&);
    /*10*/ virtual void initializeComponents(int /*enum enum Actor::InitializationMethod*/, class VariantParameterList const&);
    /*11*/ virtual void reloadComponents(int /*enum enum Actor::InitializationMethod*/, class VariantParameterList const&);
    /*12*/ virtual void _serverInitItemStackIds();
    /*13*/ virtual void _doInitialMove();
    /*14*/ virtual ~Actor();
    /*15*/ virtual void reset();
    /*16*/ virtual int getOnDeathExperience();
    /*17*/ virtual int /*enum enum ActorType*/ getOwnerEntityType();
    /*18*/ virtual void remove();
    /*19*/ virtual void setPos(class Vec3 const&);
    /*20*/ virtual bool isRuntimePredictedMovementEnabled() const;
    /*21*/ virtual struct PredictedMovementValues const& getPredictedMovementValues() const;
    /*22*/ virtual void __unk_vfn_0();
    /*23*/ virtual class Vec3 const& getPosOld() const;
    /*24*/ virtual class Vec3 const getPosExtrapolated(float) const;
    /*25*/ virtual class Vec3 getAttachPos(int /*enum enum ActorLocation*/, float) const;
    /*26*/ virtual class Vec3 getFiringPos() const;
    /*27*/ virtual void setRot(class Vec2 const&);
    /*28*/ virtual void move(class Vec3 const&);
    /*29*/ virtual void move(struct IActorMovementProxy&, class Vec3 const&) const;
    /*30*/ virtual class Vec3 getInterpolatedRidingPosition(float) const;
    /*31*/ virtual float getInterpolatedBodyRot(float) const;
    /*32*/ virtual float getInterpolatedHeadRot(float) const;
    /*33*/ virtual float getInterpolatedBodyYaw(float) const;
    /*34*/ virtual float getYawSpeedInDegreesPerSecond() const;
    /*35*/ virtual float getInterpolatedWalkAnimSpeed(float) const;
    /*36*/ virtual class Vec3 getInterpolatedRidingOffset(float) const;
    /*37*/ virtual void checkBlockCollisions(class AABB const&, class std::function<void (class BlockSource&, class Block const&, class BlockPos const&, class Actor&)>);
    /*38*/ virtual void updateEntityInside(class AABB const&);
    /*39*/ virtual void updateEntityInside();
    /*40*/ virtual bool isFireImmune() const;
    /*41*/ virtual void __unk_vfn_1();
    /*42*/ virtual void blockedByShield(class ActorDamageSource const&, class Actor&);
    /*43*/ virtual void teleportTo(class Vec3 const&, bool, int, int);
    /*44*/ virtual bool tryTeleportTo(class Vec3 const&, bool, bool, int, int);
    /*45*/ virtual void chorusFruitTeleport(class Vec3 const&);
    /*46*/ virtual void lerpMotion(class Vec3 const&);
    /*47*/ virtual std::unique_ptr<class AddActorBasePacket> tryCreateAddActorPacket();
    /*48*/ virtual void normalTick();
    /*49*/ virtual void baseTick();
    /*50*/ virtual void vehicleTick();
    /*51*/ virtual void positionPassenger(class Actor&, float);
    /*52*/ virtual float getRidingHeight();
    /*53*/ virtual bool startRiding(class Actor&);
    /*54*/ virtual void addPassenger(class Actor&);
    /*55*/ virtual void flagPassengerToRemove(class Actor&);
    /*56*/ virtual std::string getExitTip(std::string const&, int /*enum enum InputMode*/) const;
    /*57*/ virtual bool intersects(class Vec3 const&, class Vec3 const&) const;
    /*58*/ virtual bool isInWall() const;
    /*59*/ virtual bool isInvisible() const;
    /*60*/ virtual bool canShowNameTag() const;
    /*61*/ virtual void __unk_vfn_2();
    /*62*/ virtual void setNameTagVisible(bool);
    /*63*/ virtual std::string const& getNameTag() const;
    /*64*/ virtual unsigned __int64 getNameTagAsHash() const;
    /*65*/ virtual std::string getFormattedNameTag() const;
    /*66*/ virtual void filterFormattedNameTag(class UIProfanityContext const&);
    /*67*/ virtual void setNameTag(std::string const&);
    /*68*/ virtual void __unk_vfn_3();
    /*69*/ virtual void setScoreTag(std::string const&);
    /*70*/ virtual std::string const& getScoreTag() const;
    /*71*/ virtual bool isInWater() const;
    /*72*/ virtual bool hasEnteredWater() const;
    /*73*/ virtual bool isInLava() const;
    /*74*/ virtual bool isUnderLiquid(int /*enum enum MaterialType*/) const;
    /*75*/ virtual bool isOverWater() const;
    /*76*/ virtual void setBlockMovementSlowdownMultiplier(class Vec3 const&);
    /*77*/ virtual void resetBlockMovementSlowdownMultiplier();
    /*78*/ virtual float getCameraOffset() const;
    /*79*/ virtual float getShadowHeightOffs();
    /*80*/ virtual float getShadowRadius() const;
    /*81*/ virtual class Vec3 getHeadLookVector(float) const;
    /*82*/ virtual void __unk_vfn_4();
    /*83*/ virtual bool canSee(class Actor const&) const;
    /*84*/ virtual bool canSee(class Vec3 const&) const;
    /*85*/ virtual bool isSkyLit(float);
    /*86*/ virtual float getBrightness(float) const;
    /*87*/ virtual void __unk_vfn_5();
    /*88*/ virtual void playerTouch(class Player&);
    /*89*/ virtual void onAboveBubbleColumn(bool);
    /*90*/ virtual void onInsideBubbleColumn(bool);
    /*91*/ virtual bool isImmobile() const;
    /*92*/ virtual bool isSilent();
    /*93*/ virtual bool isPickable();
    /*94*/ virtual void __unk_vfn_6();
    /*95*/ virtual bool isSleeping() const;
    /*96*/ virtual void setSleeping(bool);
    /*97*/ virtual void __unk_vfn_7();
    /*98*/ virtual void setSneaking(bool);
    /*99*/ virtual bool isBlocking() const;
    /*100*/ virtual bool isDamageBlocked(class ActorDamageSource const&) const;
    /*101*/ virtual bool isAlive() const;
    /*102*/ virtual bool isOnFire() const;
    /*103*/ virtual bool isOnHotBlock() const;
    /*104*/ virtual void __unk_vfn_8();
    /*105*/ virtual bool isSurfaceMob() const;
    /*106*/ virtual void __unk_vfn_9();
    /*107*/ virtual void __unk_vfn_10();
    /*108*/ virtual void __unk_vfn_11();
    /*109*/ virtual bool isAffectedByWaterBottle() const;
    /*110*/ virtual bool canAttack(class Actor*, bool) const;
    /*111*/ virtual void setTarget(class Actor*);
    /*112*/ virtual class Actor* findAttackTarget();
    /*113*/ virtual bool isValidTarget(class Actor*) const;
    /*114*/ virtual bool attack(class Actor&, int /*enum enum ActorDamageCause*/ const&);
    /*115*/ virtual void performRangedAttack(class Actor&, float);
    /*116*/ virtual void adjustDamageAmount(int&) const;
    /*117*/ virtual int getEquipmentCount() const;
    /*118*/ virtual void setOwner(struct ActorUniqueID);
    /*119*/ virtual void setSitting(bool);
    /*120*/ virtual void onTame();
    /*121*/ virtual void onFailedTame();
    /*122*/ virtual int getInventorySize() const;
    /*123*/ virtual int getEquipSlots() const;
    /*124*/ virtual int getChestSlots() const;
    /*125*/ virtual void setStanding(bool);
    /*126*/ virtual bool canPowerJump() const;
    /*127*/ virtual void setCanPowerJump(bool);
    /*128*/ virtual bool isJumping() const;
    /*129*/ virtual bool isEnchanted() const;
    /*130*/ virtual void vehicleLanded(class Vec3 const&, class Vec3 const&);
    /*131*/ virtual bool shouldRender() const;
    /*132*/ virtual void playAmbientSound();
    /*133*/ virtual int /*enum enum LevelSoundEvent*/ getAmbientSound() const;
    /*134*/ virtual bool isInvulnerableTo(class ActorDamageSource const&) const;
    /*135*/ virtual int /*enum enum ActorDamageCause*/ getBlockDamageCause(class Block const&) const;
    /*136*/ virtual void actuallyHurt(int, class ActorDamageSource const&, bool);
    /*137*/ virtual void animateHurt();
    /*138*/ virtual bool doFireHurt(int);
    /*139*/ virtual void onLightningHit();
    /*140*/ virtual void onBounceStarted(class BlockPos const&, class Block const&);
    /*141*/ virtual void feed(int);
    /*142*/ virtual void handleEntityEvent(int /*enum enum ActorEvent*/, int);
    /*143*/ virtual void __unk_vfn_12();
    /*144*/ virtual class HashedString const& getActorRendererId() const;
    /*145*/ virtual class ItemActor* spawnAtLocation(int, int);
    /*146*/ virtual class ItemActor* spawnAtLocation(int, int, float);
    /*147*/ virtual class ItemActor* spawnAtLocation(class Block const&, int);
    /*148*/ virtual class ItemActor* spawnAtLocation(class Block const&, int, float);
    /*149*/ virtual class ItemActor* spawnAtLocation(class ItemStack const&, float);
    /*150*/ virtual void despawn();
    /*151*/ virtual void killed(class Actor&);
    /*152*/ virtual void awardKillScore(class Actor&, int);
    /*153*/ virtual void setArmor(int /*enum enum ArmorSlot*/, class ItemStack const&);
    /*154*/ virtual class ItemStack const& getArmor(int /*enum enum ArmorSlot*/) const;
    /*155*/ virtual std::vector<class ItemStack const*> getAllArmor() const;
    /*156*/ virtual int /*enum enum ArmorMaterialType*/ getArmorMaterialTypeInSlot(int /*enum enum ArmorSlot*/) const;
    /*157*/ virtual int /*enum enum ArmorTextureType*/ getArmorMaterialTextureTypeInSlot(int /*enum enum ArmorSlot*/) const;
    /*158*/ virtual float getArmorColorInSlot(int /*enum enum ArmorSlot*/, int) const;
    /*159*/ virtual class ItemStack const& getEquippedSlot(int /*enum enum EquipmentSlot*/) const;
    /*160*/ virtual void setEquippedSlot(int /*enum enum EquipmentSlot*/, class ItemStack const&);
    /*161*/ virtual class ItemStack const& getCarriedItem() const;
    /*162*/ virtual void setCarriedItem(class ItemStack const&);
    /*163*/ virtual void setOffhandSlot(class ItemStack const&);
    /*164*/ virtual class ItemStack const& getEquippedTotem() const;
    /*165*/ virtual bool consumeTotem();
    /*166*/ virtual bool save(class CompoundTag&);
    /*167*/ virtual void saveWithoutId(class CompoundTag&);
    /*168*/ virtual bool load(class CompoundTag const&, class DataLoadHelper&);
    /*169*/ virtual void loadLinks(class CompoundTag const&, std::vector<struct ActorLink>&, class DataLoadHelper&);
    /*170*/ virtual int /*enum enum ActorType*/ getEntityTypeId() const;
    /*171*/ virtual class HashedString const& queryEntityRenderer() const;
    /*172*/ virtual struct ActorUniqueID getSourceUniqueID() const;
    /*173*/ virtual void thawFreezeEffect();
    /*174*/ virtual bool canFreeze() const;
    /*175*/ virtual bool const isWearingLeatherArmor() const;
    /*176*/ virtual class AABB getLiquidAABB(int /*enum enum MaterialType*/) const;
    /*177*/ virtual void handleInsidePortal(class BlockPos const&);
    /*178*/ virtual int getPortalCooldown() const;
    /*179*/ virtual int getPortalWaitTime() const;
    /*180*/ virtual class AutomaticID<class Dimension, int> getDimensionId() const;
    /*181*/ virtual bool canChangeDimensions() const;
    /*182*/ virtual void __unk_vfn_13();
    /*183*/ virtual void changeDimension(class AutomaticID<class Dimension, int>, bool);
    /*184*/ virtual struct ActorUniqueID getControllingPlayer() const;
    /*185*/ virtual void checkFallDamage(float, bool);
    /*186*/ virtual void causeFallDamage(float, float, class ActorDamageSource);
    /*187*/ virtual void handleFallDistanceOnServer(float, float, bool);
    /*188*/ virtual void playSynchronizedSound(int /*enum enum LevelSoundEvent*/, class Vec3 const&, class Block const&, bool);
    /*189*/ virtual void playSynchronizedSound(int /*enum enum LevelSoundEvent*/, class Vec3 const&, int, bool);
    /*190*/ virtual void onSynchedFlagUpdate(int, __int64, __int64);
    /*191*/ virtual void onSynchedDataUpdate(int);
    /*192*/ virtual bool canAddPassenger(class Actor&) const;
    /*193*/ virtual bool canPickupItem(class ItemStack const&) const;
    /*194*/ virtual bool canBePulledIntoVehicle() const;
    /*195*/ virtual bool inCaravan() const;
    /*196*/ virtual void __unk_vfn_14();
    /*197*/ virtual void tickLeash();
    /*198*/ virtual void sendMotionPacketIfNeeded();
    /*199*/ virtual bool canSynchronizeNewEntity() const;
    /*200*/ virtual void stopRiding(bool, bool, bool);
    /*201*/ virtual void startSwimming();
    /*202*/ virtual void stopSwimming();
    /*203*/ virtual void buildDebugInfo(std::string&) const;
    /*204*/ virtual int /*enum enum CommandPermissionLevel*/ getCommandPermissionLevel() const;
    /*205*/ virtual bool isClientSide() const;
    /*206*/ virtual class AttributeInstance* getMutableAttribute(class Attribute const&);
    /*207*/ virtual class AttributeInstance const& getAttribute(class Attribute const&) const;
    /*208*/ virtual int getDeathTime() const;
    /*209*/ virtual void heal(int);
    /*210*/ virtual bool isInvertedHealAndHarm() const;
    /*211*/ virtual bool canBeAffected(int) const;
    /*212*/ virtual bool canBeAffected(class MobEffectInstance const&) const;
    /*213*/ virtual bool canBeAffectedByArrow(class MobEffectInstance const&) const;
    /*214*/ virtual void onEffectAdded(class MobEffectInstance&);
    /*215*/ virtual void onEffectUpdated(class MobEffectInstance&);
    /*216*/ virtual void onEffectRemoved(class MobEffectInstance&);
    /*217*/ virtual class AnimationComponent& getAnimationComponent();
    /*218*/ virtual void openContainerComponent(class Player&);
    /*219*/ virtual void swing();
    /*220*/ virtual void useItem(class ItemStackBase&, int /*enum enum ItemUseMethod*/, bool);
    /*221*/ virtual void __unk_vfn_15();
    /*222*/ virtual void __unk_vfn_16();
    /*223*/ virtual void getDebugText(std::vector<std::string>&);
    /*224*/ virtual float getMapDecorationRotation() const;
    /*225*/ virtual float getPassengerYRotation(class Actor const&) const;
    /*226*/ virtual float getYHeadRot() const;
    /*227*/ virtual bool isWorldBuilder() const;
    /*228*/ virtual void __unk_vfn_17();
    /*229*/ virtual bool isAdventure() const;
    /*230*/ virtual bool add(class ItemStack&);
    /*231*/ virtual bool drop(class ItemStack const&, bool);
    /*232*/ virtual bool getInteraction(class Player&, class ActorInteraction&, class Vec3 const&);
    /*233*/ virtual bool canDestroyBlock(class Block const&) const;
    /*234*/ virtual void setAuxValue(int);
    /*235*/ virtual void setSize(float, float);
    /*236*/ virtual void onOrphan();
    /*237*/ virtual void wobble();
    /*238*/ virtual bool wasHurt();
    /*239*/ virtual void startSpinAttack();
    /*240*/ virtual void stopSpinAttack();
    /*241*/ virtual void setDamageNearbyMobs(bool);
    /*242*/ virtual void __unk_vfn_18();
    /*243*/ virtual void reloadLootTable();
    /*244*/ virtual void reloadLootTable(struct EquipmentTableDefinition const&);
    /*245*/ virtual void __unk_vfn_19();
    /*246*/ virtual void kill();
    /*247*/ virtual void die(class ActorDamageSource const&);
    /*248*/ virtual bool shouldDropDeathLoot() const;
    /*249*/ virtual bool shouldTick() const;
    /*250*/ virtual void extractSnapshot(struct PlayerSnapshotComponent&) const;
    /*251*/ virtual void applySnapshot(struct PlayerSnapshotComponent const&, struct PlayerSnapshotComponent const&);
    /*252*/ virtual float getNextStep(float);
    /*253*/ virtual class LootTable* getLootTable();
    /*254*/ virtual void interpolatorTick();
    /*255*/ virtual void updateEntitySpecificMolangVariables(class RenderParams&);
    /*256*/ virtual bool shouldTryMakeStepSound();
    /*257*/ virtual void __unk_vfn_20();
    /*258*/ virtual bool _hurt(class ActorDamageSource const&, int, bool, bool);
    /*259*/ virtual void markHurt();
    /*260*/ virtual class AnimationComponent& _getAnimationComponent(class std::shared_ptr<class AnimationComponent>&, int /*enum enum AnimationComponentGroup*/);
    /*261*/ virtual void readAdditionalSaveData(class CompoundTag const&, class DataLoadHelper&);
    /*262*/ virtual void addAdditionalSaveData(class CompoundTag&);
    /*263*/ virtual void _playStepSound(class BlockPos const&, class Block const&);
    /*264*/ virtual void _playFlySound(class BlockPos const&, class Block const&);
    /*265*/ virtual void __unk_vfn_21();
    /*266*/ virtual void checkInsideBlocks(float);
    /*267*/ virtual void pushOutOfBlocks(class Vec3 const&);
    /*268*/ virtual bool updateWaterState();
    /*269*/ virtual void doWaterSplashEffect();
    /*270*/ virtual void spawnTrailBubbles();
    /*271*/ virtual void updateInsideBlock();
    /*272*/ virtual void _removePassenger(struct ActorUniqueID const&, bool, bool, bool);
    /*273*/ virtual void _onSizeUpdated();
    /*
    inline bool canSeeInvisible() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?canSeeInvisible@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool inCaravan() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?inCaravan@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isCreative() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isCreative@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isBlocking() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isBlocking@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isCreativeModeAllowed(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?isCreativeModeAllowed@Actor@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool canFreeze() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?canFreeze@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isWorldBuilder() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isWorldBuilder@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isPickable(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?isPickable@Actor@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool isLocalPlayer() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isLocalPlayer@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isAdventure() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isAdventure@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isLeashableType(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?isLeashableType@Actor@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool hasOutputSignal(unsigned char a0) const{
        bool (Actor::*rv)(unsigned char) const;
        *((void**)&rv) = dlsym("?hasOutputSignal@Actor@@UEBA_NE@Z");
        return (this->*rv)(std::forward<unsigned char>(a0));
    }
    inline bool breaksFallingBlocks() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?breaksFallingBlocks@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isShootable(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?isShootable@Actor@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool _makeFlySound() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?_makeFlySound@Actor@@MEBA_NXZ");
        return (this->*rv)();
    }
    inline bool canBePulledIntoVehicle() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?canBePulledIntoVehicle@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isDamageBlocked(class ActorDamageSource const& a0) const{
        bool (Actor::*rv)(class ActorDamageSource const&) const;
        *((void**)&rv) = dlsym("?isDamageBlocked@Actor@@UEBA_NAEBVActorDamageSource@@@Z");
        return (this->*rv)(std::forward<class ActorDamageSource const&>(a0));
    }
    inline bool isJumping() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isJumping@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isPlayer() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isPlayer@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool getAlwaysShowNameTag() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getAlwaysShowNameTag@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool interactPreventDefault(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?interactPreventDefault@Actor@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool isSleeping() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isSleeping@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline int getDeathTime() const{
        int (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getDeathTime@Actor@@UEBAHXZ");
        return (this->*rv)();
    }
    inline int getOutputSignal() const{
        int (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getOutputSignal@Actor@@UEBAHXZ");
        return (this->*rv)();
    }
    inline class Actor* findAttackTarget(){
        class Actor* (Actor::*rv)();
        *((void**)&rv) = dlsym("?findAttackTarget@Actor@@UEAAPEAV1@XZ");
        return (this->*rv)();
    }
    inline int getPortalWaitTime() const{
        int (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getPortalWaitTime@Actor@@UEBAHXZ");
        return (this->*rv)();
    }
    inline void onFailedTame(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?onFailedTame@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void _onSizeUpdated(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?_onSizeUpdated@Actor@@EEAAXXZ");
        return (this->*rv)();
    }
    inline void animateHurt(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?animateHurt@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void reloadHardcoded(int \/*enum enum Actor::InitializationMethod*\/ a0, class VariantParameterList const& a1){
        void (Actor::*rv)(int \/*enum enum Actor::InitializationMethod*\/, class VariantParameterList const&);
        *((void**)&rv) = dlsym("?reloadHardcoded@Actor@@MEAAXW4InitializationMethod@1@AEBVVariantParameterList@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum Actor::InitializationMethod*\/>(a0), std::forward<class VariantParameterList const&>(a1));
    }
    inline void awardKillScore(class Actor& a0, int a1){
        void (Actor::*rv)(class Actor&, int);
        *((void**)&rv) = dlsym("?awardKillScore@Actor@@UEAAXAEAV1@H@Z");
        return (this->*rv)(std::forward<class Actor&>(a0), std::forward<int>(a1));
    }
    inline void playerTouch(class Player& a0){
        void (Actor::*rv)(class Player&);
        *((void**)&rv) = dlsym("?playerTouch@Actor@@UEAAXAEAVPlayer@@@Z");
        return (this->*rv)(std::forward<class Player&>(a0));
    }
    inline void swing(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?swing@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void vehicleLanded(class Vec3 const& a0, class Vec3 const& a1){
        void (Actor::*rv)(class Vec3 const&, class Vec3 const&);
        *((void**)&rv) = dlsym("?vehicleLanded@Actor@@UEAAXAEBVVec3@@0@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0), std::forward<class Vec3 const&>(a1));
    }
    inline void changeDimension(class ChangeDimensionPacket const& a0){
        void (Actor::*rv)(class ChangeDimensionPacket const&);
        *((void**)&rv) = dlsym("?changeDimension@Actor@@UEAAXAEBVChangeDimensionPacket@@@Z");
        return (this->*rv)(std::forward<class ChangeDimensionPacket const&>(a0));
    }
    inline void buildDebugInfo(std::string& a0) const{
        void (Actor::*rv)(std::string&) const;
        *((void**)&rv) = dlsym("?buildDebugInfo@Actor@@UEBAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string&>(a0));
    }
    inline void stopSpinAttack(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?stopSpinAttack@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void renderDebugServerState(class Options const& a0){
        void (Actor::*rv)(class Options const&);
        *((void**)&rv) = dlsym("?renderDebugServerState@Actor@@UEAAXAEBVOptions@@@Z");
        return (this->*rv)(std::forward<class Options const&>(a0));
    }
    inline void setAuxValue(int a0){
        void (Actor::*rv)(int);
        *((void**)&rv) = dlsym("?setAuxValue@Actor@@UEAAXH@Z");
        return (this->*rv)(std::forward<int>(a0));
    }
    inline void onTame(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?onTame@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void setSleeping(bool a0){
        void (Actor::*rv)(bool);
        *((void**)&rv) = dlsym("?setSleeping@Actor@@UEAAX_N@Z");
        return (this->*rv)(std::forward<bool>(a0));
    }
    inline void onBounceStarted(class BlockPos const& a0, class Block const& a1){
        void (Actor::*rv)(class BlockPos const&, class Block const&);
        *((void**)&rv) = dlsym("?onBounceStarted@Actor@@UEAAXAEBVBlockPos@@AEBVBlock@@@Z");
        return (this->*rv)(std::forward<class BlockPos const&>(a0), std::forward<class Block const&>(a1));
    }
    inline void _doAutoAttackOnTouch(class Actor& a0){
        void (Actor::*rv)(class Actor&);
        *((void**)&rv) = dlsym("?_doAutoAttackOnTouch@Actor@@EEAAXAEAV1@@Z");
        return (this->*rv)(std::forward<class Actor&>(a0));
    }
    inline void adjustDamageAmount(int& a0) const{
        void (Actor::*rv)(int&) const;
        *((void**)&rv) = dlsym("?adjustDamageAmount@Actor@@UEBAXAEAH@Z");
        return (this->*rv)(std::forward<int&>(a0));
    }
    inline void setEquippedSlot(int \/*enum enum EquipmentSlot*\/ a0, class ItemStack const& a1){
        void (Actor::*rv)(int \/*enum enum EquipmentSlot*\/, class ItemStack const&);
        *((void**)&rv) = dlsym("?setEquippedSlot@Actor@@UEAAXW4EquipmentSlot@@AEBVItemStack@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum EquipmentSlot*\/>(a0), std::forward<class ItemStack const&>(a1));
    }
    inline void updateEntitySpecificMolangVariables(class RenderParams& a0){
        void (Actor::*rv)(class RenderParams&);
        *((void**)&rv) = dlsym("?updateEntitySpecificMolangVariables@Actor@@MEAAXAEAVRenderParams@@@Z");
        return (this->*rv)(std::forward<class RenderParams&>(a0));
    }
    inline bool canSynchronizeNewEntity() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?canSynchronizeNewEntity@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool canChangeDimensions() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?canChangeDimensions@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool canDestroyBlock(class Block const& a0) const{
        bool (Actor::*rv)(class Block const&) const;
        *((void**)&rv) = dlsym("?canDestroyBlock@Actor@@UEBA_NAEBVBlock@@@Z");
        return (this->*rv)(std::forward<class Block const&>(a0));
    }
    inline bool isValidTarget(class Actor* a0) const{
        bool (Actor::*rv)(class Actor*) const;
        *((void**)&rv) = dlsym("?isValidTarget@Actor@@UEBA_NPEAV1@@Z");
        return (this->*rv)(std::forward<class Actor*>(a0));
    }
    inline bool canExistInPeaceful() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?canExistInPeaceful@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isRuntimePredictedMovementEnabled() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isRuntimePredictedMovementEnabled@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isFishable() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isFishable@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isSurfaceMob() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isSurfaceMob@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool canPickupItem(class ItemStack const& a0) const{
        bool (Actor::*rv)(class ItemStack const&) const;
        *((void**)&rv) = dlsym("?canPickupItem@Actor@@UEBA_NAEBVItemStack@@@Z");
        return (this->*rv)(std::forward<class ItemStack const&>(a0));
    }
    inline bool isTargetable() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isTargetable@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool canMakeStepSound() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?canMakeStepSound@Actor@@MEBA_NXZ");
        return (this->*rv)();
    }
    inline float getPickRadius(){
        float (Actor::*rv)();
        *((void**)&rv) = dlsym("?getPickRadius@Actor@@UEAAMXZ");
        return (this->*rv)();
    }
    inline float getInterpolatedHeadRot(float a0) const{
        float (Actor::*rv)(float) const;
        *((void**)&rv) = dlsym("?getInterpolatedHeadRot@Actor@@UEBAMM@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline float getInterpolatedBodyYaw(float a0) const{
        float (Actor::*rv)(float) const;
        *((void**)&rv) = dlsym("?getInterpolatedBodyYaw@Actor@@UEBAMM@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline float getCameraOffset() const{
        float (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getCameraOffset@Actor@@UEBAMXZ");
        return (this->*rv)();
    }
    inline float getDeletionDelayTimeSeconds() const{
        float (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getDeletionDelayTimeSeconds@Actor@@UEBAMXZ");
        return (this->*rv)();
    }
    inline float getYHeadRot() const{
        float (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getYHeadRot@Actor@@UEBAMXZ");
        return (this->*rv)();
    }
    inline float getArmorColorInSlot(int \/*enum enum ArmorSlot*\/ a0, int a1) const{
        float (Actor::*rv)(int \/*enum enum ArmorSlot*\/, int) const;
        *((void**)&rv) = dlsym("?getArmorColorInSlot@Actor@@UEBAMW4ArmorSlot@@H@Z");
        return (this->*rv)(std::forward<int \/*enum enum ArmorSlot*\/>(a0), std::forward<int>(a1));
    }
    inline int \/*enum enum ArmorMaterialType*\/ getArmorMaterialTypeInSlot(int \/*enum enum ArmorSlot*\/ a0) const{
        int \/*enum enum ArmorMaterialType*\/ (Actor::*rv)(int \/*enum enum ArmorSlot*\/) const;
        *((void**)&rv) = dlsym("?getArmorMaterialTypeInSlot@Actor@@UEBA?AW4ArmorMaterialType@@W4ArmorSlot@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum ArmorSlot*\/>(a0));
    }
    inline int \/*enum enum ArmorTextureType*\/ getArmorMaterialTextureTypeInSlot(int \/*enum enum ArmorSlot*\/ a0) const{
        int \/*enum enum ArmorTextureType*\/ (Actor::*rv)(int \/*enum enum ArmorSlot*\/) const;
        *((void**)&rv) = dlsym("?getArmorMaterialTextureTypeInSlot@Actor@@UEBA?AW4ArmorTextureType@@W4ArmorSlot@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum ArmorSlot*\/>(a0));
    }
    inline class Vec3 getHeadLookVector(float a0) const{
        class Vec3 (Actor::*rv)(float) const;
        *((void**)&rv) = dlsym("?getHeadLookVector@Actor@@UEBA?AVVec3@@M@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline class Vec3 getInterpolatedRidingOffset(float a0) const{
        class Vec3 (Actor::*rv)(float) const;
        *((void**)&rv) = dlsym("?getInterpolatedRidingOffset@Actor@@UEBA?AVVec3@@M@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline void _doInitialMove(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?_doInitialMove@Actor@@MEAAXXZ");
        return (this->*rv)();
    }
    inline class AnimationComponent& _getAnimationComponent(class std::shared_ptr<class AnimationComponent>& a0, int \/*enum enum AnimationComponentGroup*\/ a1){
        class AnimationComponent& (Actor::*rv)(class std::shared_ptr<class AnimationComponent>&, int \/*enum enum AnimationComponentGroup*\/);
        *((void**)&rv) = dlsym("?_getAnimationComponent@Actor@@MEAAAEAVAnimationComponent@@AEAV?$shared_ptr@VAnimationComponent@@@std@@W4AnimationComponentGroup@@@Z");
        return (this->*rv)(std::forward<class std::shared_ptr<class AnimationComponent>&>(a0), std::forward<int \/*enum enum AnimationComponentGroup*\/>(a1));
    }
    inline bool _hurt(class ActorDamageSource const& a0, int a1, bool a2, bool a3){
        bool (Actor::*rv)(class ActorDamageSource const&, int, bool, bool);
        *((void**)&rv) = dlsym("?_hurt@Actor@@MEAA_NAEBVActorDamageSource@@H_N1@Z");
        return (this->*rv)(std::forward<class ActorDamageSource const&>(a0), std::forward<int>(a1), std::forward<bool>(a2), std::forward<bool>(a3));
    }
    inline void _playFlySound(class BlockPos const& a0, class Block const& a1){
        void (Actor::*rv)(class BlockPos const&, class Block const&);
        *((void**)&rv) = dlsym("?_playFlySound@Actor@@MEAAXAEBVBlockPos@@AEBVBlock@@@Z");
        return (this->*rv)(std::forward<class BlockPos const&>(a0), std::forward<class Block const&>(a1));
    }
    inline void _playStepSound(class BlockPos const& a0, class Block const& a1){
        void (Actor::*rv)(class BlockPos const&, class Block const&);
        *((void**)&rv) = dlsym("?_playStepSound@Actor@@MEAAXAEBVBlockPos@@AEBVBlock@@@Z");
        return (this->*rv)(std::forward<class BlockPos const&>(a0), std::forward<class Block const&>(a1));
    }
    inline void _removePassenger(struct ActorUniqueID const& a0, bool a1, bool a2, bool a3){
        void (Actor::*rv)(struct ActorUniqueID const&, bool, bool, bool);
        *((void**)&rv) = dlsym("?_removePassenger@Actor@@MEAAXAEBUActorUniqueID@@_N11@Z");
        return (this->*rv)(std::forward<struct ActorUniqueID const&>(a0), std::forward<bool>(a1), std::forward<bool>(a2), std::forward<bool>(a3));
    }
    inline void _serverInitItemStackIds(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?_serverInitItemStackIds@Actor@@MEAAXXZ");
        return (this->*rv)();
    }
    inline void actuallyHurt(int a0, class ActorDamageSource const& a1, bool a2){
        void (Actor::*rv)(int, class ActorDamageSource const&, bool);
        *((void**)&rv) = dlsym("?actuallyHurt@Actor@@UEAAXHAEBVActorDamageSource@@_N@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<class ActorDamageSource const&>(a1), std::forward<bool>(a2));
    }
    inline bool add(class ItemStack& a0){
        bool (Actor::*rv)(class ItemStack&);
        *((void**)&rv) = dlsym("?add@Actor@@UEAA_NAEAVItemStack@@@Z");
        return (this->*rv)(std::forward<class ItemStack&>(a0));
    }
    inline void addAdditionalSaveData(class CompoundTag& a0){
        void (Actor::*rv)(class CompoundTag&);
        *((void**)&rv) = dlsym("?addAdditionalSaveData@Actor@@MEAAXAEAVCompoundTag@@@Z");
        return (this->*rv)(std::forward<class CompoundTag&>(a0));
    }
    inline void addPassenger(class Actor& a0){
        void (Actor::*rv)(class Actor&);
        *((void**)&rv) = dlsym("?addPassenger@Actor@@UEAAXAEAV1@@Z");
        return (this->*rv)(std::forward<class Actor&>(a0));
    }
    inline void applySnapshot(struct PlayerSnapshotComponent const& a0, struct PlayerSnapshotComponent const& a1){
        void (Actor::*rv)(struct PlayerSnapshotComponent const&, struct PlayerSnapshotComponent const&);
        *((void**)&rv) = dlsym("?applySnapshot@Actor@@UEAAXAEBUPlayerSnapshotComponent@@0@Z");
        return (this->*rv)(std::forward<struct PlayerSnapshotComponent const&>(a0), std::forward<struct PlayerSnapshotComponent const&>(a1));
    }
    inline bool attack(class Actor& a0, int \/*enum enum ActorDamageCause*\/ const& a1){
        bool (Actor::*rv)(class Actor&, int \/*enum enum ActorDamageCause*\/ const&);
        *((void**)&rv) = dlsym("?attack@Actor@@UEAA_NAEAV1@AEBW4ActorDamageCause@@@Z");
        return (this->*rv)(std::forward<class Actor&>(a0), std::forward<int \/*enum enum ActorDamageCause*\/ const&>(a1));
    }
    inline void baseTick(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?baseTick@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void blockedByShield(class ActorDamageSource const& a0, class Actor& a1){
        void (Actor::*rv)(class ActorDamageSource const&, class Actor&);
        *((void**)&rv) = dlsym("?blockedByShield@Actor@@UEAAXAEBVActorDamageSource@@AEAV1@@Z");
        return (this->*rv)(std::forward<class ActorDamageSource const&>(a0), std::forward<class Actor&>(a1));
    }
    inline bool canAddPassenger(class Actor& a0) const{
        bool (Actor::*rv)(class Actor&) const;
        *((void**)&rv) = dlsym("?canAddPassenger@Actor@@UEBA_NAEAV1@@Z");
        return (this->*rv)(std::forward<class Actor&>(a0));
    }
    inline bool canAttack(class Actor* a0, bool a1) const{
        bool (Actor::*rv)(class Actor*, bool) const;
        *((void**)&rv) = dlsym("?canAttack@Actor@@UEBA_NPEAV1@_N@Z");
        return (this->*rv)(std::forward<class Actor*>(a0), std::forward<bool>(a1));
    }
    inline bool canBeAffected(class MobEffectInstance const& a0) const{
        bool (Actor::*rv)(class MobEffectInstance const&) const;
        *((void**)&rv) = dlsym("?canBeAffected@Actor@@UEBA_NAEBVMobEffectInstance@@@Z");
        return (this->*rv)(std::forward<class MobEffectInstance const&>(a0));
    }
    inline bool canBeAffected(int a0) const{
        bool (Actor::*rv)(int) const;
        *((void**)&rv) = dlsym("?canBeAffected@Actor@@UEBA_NH@Z");
        return (this->*rv)(std::forward<int>(a0));
    }
    inline bool canBeAffectedByArrow(class MobEffectInstance const& a0) const{
        bool (Actor::*rv)(class MobEffectInstance const&) const;
        *((void**)&rv) = dlsym("?canBeAffectedByArrow@Actor@@UEBA_NAEBVMobEffectInstance@@@Z");
        return (this->*rv)(std::forward<class MobEffectInstance const&>(a0));
    }
    inline bool canPowerJump() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?canPowerJump@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool canSee(class Actor const& a0) const{
        bool (Actor::*rv)(class Actor const&) const;
        *((void**)&rv) = dlsym("?canSee@Actor@@UEBA_NAEBV1@@Z");
        return (this->*rv)(std::forward<class Actor const&>(a0));
    }
    inline bool canSee(class Vec3 const& a0) const{
        bool (Actor::*rv)(class Vec3 const&) const;
        *((void**)&rv) = dlsym("?canSee@Actor@@UEBA_NAEBVVec3@@@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0));
    }
    inline bool canShowNameTag() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?canShowNameTag@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline void causeFallDamage(float a0, float a1, class ActorDamageSource a2){
        void (Actor::*rv)(float, float, class ActorDamageSource);
        *((void**)&rv) = dlsym("?causeFallDamage@Actor@@UEAAXMMVActorDamageSource@@@Z");
        return (this->*rv)(std::forward<float>(a0), std::forward<float>(a1), std::forward<class ActorDamageSource>(a2));
    }
    inline void changeDimension(class AutomaticID<class Dimension, int> a0, bool a1){
        void (Actor::*rv)(class AutomaticID<class Dimension, int>, bool);
        *((void**)&rv) = dlsym("?changeDimension@Actor@@UEAAXV?$AutomaticID@VDimension@@H@@_N@Z");
        return (this->*rv)(std::forward<class AutomaticID<class Dimension, int>>(a0), std::forward<bool>(a1));
    }
    inline void checkBlockCollisions(class AABB const& a0, class std::function<void (class BlockSource&, class Block const&, class BlockPos const&, class Actor&)> a1){
        void (Actor::*rv)(class AABB const&, class std::function<void (class BlockSource&, class Block const&, class BlockPos const&, class Actor&)>);
        *((void**)&rv) = dlsym("?checkBlockCollisions@Actor@@UEAAXAEBVAABB@@V?$function@$$A6AXAEAVBlockSource@@AEBVBlock@@AEBVBlockPos@@AEAVActor@@@Z@std@@@Z");
        return (this->*rv)(std::forward<class AABB const&>(a0), std::forward<class std::function<void (class BlockSource&, class Block const&, class BlockPos const&, class Actor&)>>(a1));
    }
    inline void checkFallDamage(float a0, bool a1){
        void (Actor::*rv)(float, bool);
        *((void**)&rv) = dlsym("?checkFallDamage@Actor@@UEAAXM_N@Z");
        return (this->*rv)(std::forward<float>(a0), std::forward<bool>(a1));
    }
    inline void checkInsideBlocks(float a0){
        void (Actor::*rv)(float);
        *((void**)&rv) = dlsym("?checkInsideBlocks@Actor@@MEAAXM@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline void chorusFruitTeleport(class Vec3 const& a0){
        void (Actor::*rv)(class Vec3 const&);
        *((void**)&rv) = dlsym("?chorusFruitTeleport@Actor@@UEAAXAEBVVec3@@@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0));
    }
    inline bool consumeTotem(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?consumeTotem@Actor@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline void despawn(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?despawn@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void die(class ActorDamageSource const& a0){
        void (Actor::*rv)(class ActorDamageSource const&);
        *((void**)&rv) = dlsym("?die@Actor@@UEAAXAEBVActorDamageSource@@@Z");
        return (this->*rv)(std::forward<class ActorDamageSource const&>(a0));
    }
    inline bool doFireHurt(int a0){
        bool (Actor::*rv)(int);
        *((void**)&rv) = dlsym("?doFireHurt@Actor@@UEAA_NH@Z");
        return (this->*rv)(std::forward<int>(a0));
    }
    inline void doWaterSplashEffect(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?doWaterSplashEffect@Actor@@MEAAXXZ");
        return (this->*rv)();
    }
    inline bool drop(class ItemStack const& a0, bool a1){
        bool (Actor::*rv)(class ItemStack const&, bool);
        *((void**)&rv) = dlsym("?drop@Actor@@UEAA_NAEBVItemStack@@_N@Z");
        return (this->*rv)(std::forward<class ItemStack const&>(a0), std::forward<bool>(a1));
    }
    inline void extractSnapshot(struct PlayerSnapshotComponent& a0) const{
        void (Actor::*rv)(struct PlayerSnapshotComponent&) const;
        *((void**)&rv) = dlsym("?extractSnapshot@Actor@@UEBAXAEAUPlayerSnapshotComponent@@@Z");
        return (this->*rv)(std::forward<struct PlayerSnapshotComponent&>(a0));
    }
    inline void feed(int a0){
        void (Actor::*rv)(int);
        *((void**)&rv) = dlsym("?feed@Actor@@UEAAXH@Z");
        return (this->*rv)(std::forward<int>(a0));
    }
    inline void filterFormattedNameTag(class UIProfanityContext const& a0){
        void (Actor::*rv)(class UIProfanityContext const&);
        *((void**)&rv) = dlsym("?filterFormattedNameTag@Actor@@UEAAXAEBVUIProfanityContext@@@Z");
        return (this->*rv)(std::forward<class UIProfanityContext const&>(a0));
    }
    inline void flagPassengerToRemove(class Actor& a0){
        void (Actor::*rv)(class Actor&);
        *((void**)&rv) = dlsym("?flagPassengerToRemove@Actor@@UEAAXAEAV1@@Z");
        return (this->*rv)(std::forward<class Actor&>(a0));
    }
    inline class HashedString const& getActorRendererId() const{
        class HashedString const& (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getActorRendererId@Actor@@UEBAAEBVHashedString@@XZ");
        return (this->*rv)();
    }
    inline std::vector<class ItemStack const*> getAllArmor() const{
        std::vector<class ItemStack const*> (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getAllArmor@Actor@@UEBA?AV?$vector@PEBVItemStack@@V?$allocator@PEBVItemStack@@@std@@@std@@XZ");
        return (this->*rv)();
    }
    inline int \/*enum enum LevelSoundEvent*\/ getAmbientSound() const{
        int \/*enum enum LevelSoundEvent*\/ (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getAmbientSound@Actor@@UEBA?AW4LevelSoundEvent@@XZ");
        return (this->*rv)();
    }
    inline class AnimationComponent& getAnimationComponent(){
        class AnimationComponent& (Actor::*rv)();
        *((void**)&rv) = dlsym("?getAnimationComponent@Actor@@UEAAAEAVAnimationComponent@@XZ");
        return (this->*rv)();
    }
    inline class ItemStack const& getArmor(int \/*enum enum ArmorSlot*\/ a0) const{
        class ItemStack const& (Actor::*rv)(int \/*enum enum ArmorSlot*\/) const;
        *((void**)&rv) = dlsym("?getArmor@Actor@@UEBAAEBVItemStack@@W4ArmorSlot@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum ArmorSlot*\/>(a0));
    }
    inline class Vec3 getAttachPos(int \/*enum enum ActorLocation*\/ a0, float a1) const{
        class Vec3 (Actor::*rv)(int \/*enum enum ActorLocation*\/, float) const;
        *((void**)&rv) = dlsym("?getAttachPos@Actor@@UEBA?AVVec3@@W4ActorLocation@@M@Z");
        return (this->*rv)(std::forward<int \/*enum enum ActorLocation*\/>(a0), std::forward<float>(a1));
    }
    inline class AttributeInstance const& getAttribute(class Attribute const& a0) const{
        class AttributeInstance const& (Actor::*rv)(class Attribute const&) const;
        *((void**)&rv) = dlsym("?getAttribute@Actor@@UEBAAEBVAttributeInstance@@AEBVAttribute@@@Z");
        return (this->*rv)(std::forward<class Attribute const&>(a0));
    }
    inline int \/*enum enum ActorDamageCause*\/ getBlockDamageCause(class Block const& a0) const{
        int \/*enum enum ActorDamageCause*\/ (Actor::*rv)(class Block const&) const;
        *((void**)&rv) = dlsym("?getBlockDamageCause@Actor@@UEBA?AW4ActorDamageCause@@AEBVBlock@@@Z");
        return (this->*rv)(std::forward<class Block const&>(a0));
    }
    inline float getBrightness(float a0) const{
        float (Actor::*rv)(float) const;
        *((void**)&rv) = dlsym("?getBrightness@Actor@@UEBAMM@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline class ItemStack const& getCarriedItem() const{
        class ItemStack const& (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getCarriedItem@Actor@@UEBAAEBVItemStack@@XZ");
        return (this->*rv)();
    }
    inline int getChestSlots() const{
        int (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getChestSlots@Actor@@UEBAHXZ");
        return (this->*rv)();
    }
    inline int \/*enum enum CommandPermissionLevel*\/ getCommandPermissionLevel() const{
        int \/*enum enum CommandPermissionLevel*\/ (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getCommandPermissionLevel@Actor@@UEBA?AW4CommandPermissionLevel@@XZ");
        return (this->*rv)();
    }
    inline struct ActorUniqueID getSourceUniqueID() const{
        struct ActorUniqueID (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getSourceUniqueID@Actor@@UEBA?AUActorUniqueID@@XZ");
        return (this->*rv)();
    }
    inline struct ActorUniqueID getControllingPlayer() const{
        struct ActorUniqueID (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getControllingPlayer@Actor@@UEBA?AUActorUniqueID@@XZ");
        return (this->*rv)();
    }
    inline void getDebugText(std::vector<std::string>& a0){
        void (Actor::*rv)(std::vector<std::string>&);
        *((void**)&rv) = dlsym("?getDebugText@Actor@@UEAAXAEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z");
        return (this->*rv)(std::forward<std::vector<std::string>&>(a0));
    }
    inline class AutomaticID<class Dimension, int> getDimensionId() const{
        class AutomaticID<class Dimension, int> (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getDimensionId@Actor@@UEBA?AV?$AutomaticID@VDimension@@H@@XZ");
        return (this->*rv)();
    }
    inline int \/*enum enum ActorType*\/ getEntityTypeId() const{
        int \/*enum enum ActorType*\/ (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getEntityTypeId@Actor@@UEBA?AW4ActorType@@XZ");
        return (this->*rv)();
    }
    inline int getEquipSlots() const{
        int (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getEquipSlots@Actor@@UEBAHXZ");
        return (this->*rv)();
    }
    inline int getEquipmentCount() const{
        int (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getEquipmentCount@Actor@@UEBAHXZ");
        return (this->*rv)();
    }
    inline class ItemStack const& getEquippedSlot(int \/*enum enum EquipmentSlot*\/ a0) const{
        class ItemStack const& (Actor::*rv)(int \/*enum enum EquipmentSlot*\/) const;
        *((void**)&rv) = dlsym("?getEquippedSlot@Actor@@UEBAAEBVItemStack@@W4EquipmentSlot@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum EquipmentSlot*\/>(a0));
    }
    inline class ItemStack const& getEquippedTotem() const{
        class ItemStack const& (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getEquippedTotem@Actor@@UEBAAEBVItemStack@@XZ");
        return (this->*rv)();
    }
    inline std::string getExitTip(std::string const& a0, int \/*enum enum InputMode*\/ a1) const{
        std::string (Actor::*rv)(std::string const&, int \/*enum enum InputMode*\/) const;
        *((void**)&rv) = dlsym("?getExitTip@Actor@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@W4InputMode@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<int \/*enum enum InputMode*\/>(a1));
    }
    inline class Vec3 getFiringPos() const{
        class Vec3 (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getFiringPos@Actor@@UEBA?AVVec3@@XZ");
        return (this->*rv)();
    }
    inline std::string getFormattedNameTag() const{
        std::string (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getFormattedNameTag@Actor@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ");
        return (this->*rv)();
    }
    inline bool getInteraction(class Player& a0, class ActorInteraction& a1, class Vec3 const& a2){
        bool (Actor::*rv)(class Player&, class ActorInteraction&, class Vec3 const&);
        *((void**)&rv) = dlsym("?getInteraction@Actor@@UEAA_NAEAVPlayer@@AEAVActorInteraction@@AEBVVec3@@@Z");
        return (this->*rv)(std::forward<class Player&>(a0), std::forward<class ActorInteraction&>(a1), std::forward<class Vec3 const&>(a2));
    }
    inline float getInterpolatedBodyRot(float a0) const{
        float (Actor::*rv)(float) const;
        *((void**)&rv) = dlsym("?getInterpolatedBodyRot@Actor@@UEBAMM@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline class Vec3 getInterpolatedRidingPosition(float a0) const{
        class Vec3 (Actor::*rv)(float) const;
        *((void**)&rv) = dlsym("?getInterpolatedRidingPosition@Actor@@UEBA?AVVec3@@M@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline float getInterpolatedWalkAnimSpeed(float a0) const{
        float (Actor::*rv)(float) const;
        *((void**)&rv) = dlsym("?getInterpolatedWalkAnimSpeed@Actor@@UEBAMM@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline int getInventorySize() const{
        int (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getInventorySize@Actor@@UEBAHXZ");
        return (this->*rv)();
    }
    inline class Mob* getLastHurtByMob(){
        class Mob* (Actor::*rv)();
        *((void**)&rv) = dlsym("?getLastHurtByMob@Actor@@UEAAPEAVMob@@XZ");
        return (this->*rv)();
    }
    inline class Player* getLastHurtByPlayer(){
        class Player* (Actor::*rv)();
        *((void**)&rv) = dlsym("?getLastHurtByPlayer@Actor@@UEAAPEAVPlayer@@XZ");
        return (this->*rv)();
    }
    inline class Mob* getLastHurtMob(){
        class Mob* (Actor::*rv)();
        *((void**)&rv) = dlsym("?getLastHurtMob@Actor@@UEAAPEAVMob@@XZ");
        return (this->*rv)();
    }
    inline class AABB getLiquidAABB(int \/*enum enum MaterialType*\/ a0) const{
        class AABB (Actor::*rv)(int \/*enum enum MaterialType*\/) const;
        *((void**)&rv) = dlsym("?getLiquidAABB@Actor@@UEBA?AVAABB@@W4MaterialType@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum MaterialType*\/>(a0));
    }
    inline class LootTable* getLootTable(){
        class LootTable* (Actor::*rv)();
        *((void**)&rv) = dlsym("?getLootTable@Actor@@UEAAPEAVLootTable@@XZ");
        return (this->*rv)();
    }
    inline float getMapDecorationRotation() const{
        float (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getMapDecorationRotation@Actor@@UEBAMXZ");
        return (this->*rv)();
    }
    inline class AttributeInstance* getMutableAttribute(class Attribute const& a0){
        class AttributeInstance* (Actor::*rv)(class Attribute const&);
        *((void**)&rv) = dlsym("?getMutableAttribute@Actor@@UEAAPEAVAttributeInstance@@AEBVAttribute@@@Z");
        return (this->*rv)(std::forward<class Attribute const&>(a0));
    }
    inline std::string const& getNameTag() const{
        std::string const& (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getNameTag@Actor@@UEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ");
        return (this->*rv)();
    }
    inline unsigned __int64 getNameTagAsHash() const{
        unsigned __int64 (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getNameTagAsHash@Actor@@UEBA_KXZ");
        return (this->*rv)();
    }
    inline float getNextStep(float a0){
        float (Actor::*rv)(float);
        *((void**)&rv) = dlsym("?getNextStep@Actor@@UEAAMM@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline int getOnDeathExperience(){
        int (Actor::*rv)();
        *((void**)&rv) = dlsym("?getOnDeathExperience@Actor@@UEAAHXZ");
        return (this->*rv)();
    }
    inline int \/*enum enum ActorType*\/ getOwnerEntityType(){
        int \/*enum enum ActorType*\/ (Actor::*rv)();
        *((void**)&rv) = dlsym("?getOwnerEntityType@Actor@@UEAA?AW4ActorType@@XZ");
        return (this->*rv)();
    }
    inline float getPassengerYRotation(class Actor const& a0) const{
        float (Actor::*rv)(class Actor const&) const;
        *((void**)&rv) = dlsym("?getPassengerYRotation@Actor@@UEBAMAEBV1@@Z");
        return (this->*rv)(std::forward<class Actor const&>(a0));
    }
    inline int getPortalCooldown() const{
        int (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getPortalCooldown@Actor@@UEBAHXZ");
        return (this->*rv)();
    }
    inline class Vec3 const& getPos() const{
        class Vec3 const& (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getPos@Actor@@UEBAAEBVVec3@@XZ");
        return (this->*rv)();
    }
    inline class Vec3 const getPosExtrapolated(float a0) const{
        class Vec3 const (Actor::*rv)(float) const;
        *((void**)&rv) = dlsym("?getPosExtrapolated@Actor@@UEBA?BVVec3@@M@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline class Vec3 const& getPosOld() const{
        class Vec3 const& (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getPosOld@Actor@@UEBAAEBVVec3@@XZ");
        return (this->*rv)();
    }
    inline struct PredictedMovementValues const& getPredictedMovementValues() const{
        struct PredictedMovementValues const& (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getPredictedMovementValues@Actor@@UEBAAEBUPredictedMovementValues@@XZ");
        return (this->*rv)();
    }
    inline float getRidingHeight(){
        float (Actor::*rv)();
        *((void**)&rv) = dlsym("?getRidingHeight@Actor@@UEAAMXZ");
        return (this->*rv)();
    }
    inline std::string const& getScoreTag() const{
        std::string const& (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getScoreTag@Actor@@UEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ");
        return (this->*rv)();
    }
    inline float getShadowHeightOffs(){
        float (Actor::*rv)();
        *((void**)&rv) = dlsym("?getShadowHeightOffs@Actor@@UEAAMXZ");
        return (this->*rv)();
    }
    inline float getShadowRadius() const{
        float (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getShadowRadius@Actor@@UEBAMXZ");
        return (this->*rv)();
    }
    inline float getYawSpeedInDegreesPerSecond() const{
        float (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?getYawSpeedInDegreesPerSecond@Actor@@UEBAMXZ");
        return (this->*rv)();
    }
    inline void handleEntityEvent(int \/*enum enum ActorEvent*\/ a0, int a1){
        void (Actor::*rv)(int \/*enum enum ActorEvent*\/, int);
        *((void**)&rv) = dlsym("?handleEntityEvent@Actor@@UEAAXW4ActorEvent@@H@Z");
        return (this->*rv)(std::forward<int \/*enum enum ActorEvent*\/>(a0), std::forward<int>(a1));
    }
    inline void handleFallDistanceOnServer(float a0, float a1, bool a2){
        void (Actor::*rv)(float, float, bool);
        *((void**)&rv) = dlsym("?handleFallDistanceOnServer@Actor@@UEAAXMM_N@Z");
        return (this->*rv)(std::forward<float>(a0), std::forward<float>(a1), std::forward<bool>(a2));
    }
    inline void handleInsidePortal(class BlockPos const& a0){
        void (Actor::*rv)(class BlockPos const&);
        *((void**)&rv) = dlsym("?handleInsidePortal@Actor@@UEAAXAEBVBlockPos@@@Z");
        return (this->*rv)(std::forward<class BlockPos const&>(a0));
    }
    inline bool hasComponent(class HashedString const& a0) const{
        bool (Actor::*rv)(class HashedString const&) const;
        *((void**)&rv) = dlsym("?hasComponent@Actor@@UEBA_NAEBVHashedString@@@Z");
        return (this->*rv)(std::forward<class HashedString const&>(a0));
    }
    inline bool hasEnteredWater() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?hasEnteredWater@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline void heal(int a0){
        void (Actor::*rv)(int);
        *((void**)&rv) = dlsym("?heal@Actor@@UEAAXH@Z");
        return (this->*rv)(std::forward<int>(a0));
    }
    inline void initializeComponents(int \/*enum enum Actor::InitializationMethod*\/ a0, class VariantParameterList const& a1){
        void (Actor::*rv)(int \/*enum enum Actor::InitializationMethod*\/, class VariantParameterList const&);
        *((void**)&rv) = dlsym("?initializeComponents@Actor@@MEAAXW4InitializationMethod@1@AEBVVariantParameterList@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum Actor::InitializationMethod*\/>(a0), std::forward<class VariantParameterList const&>(a1));
    }
    inline void interpolatorTick(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?interpolatorTick@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline bool intersects(class Vec3 const& a0, class Vec3 const& a1) const{
        bool (Actor::*rv)(class Vec3 const&, class Vec3 const&) const;
        *((void**)&rv) = dlsym("?intersects@Actor@@UEBA_NAEBVVec3@@0@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0), std::forward<class Vec3 const&>(a1));
    }
    inline bool isAffectedByWaterBottle() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isAffectedByWaterBottle@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isAlive() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isAlive@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isClientSide() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isClientSide@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isEnchanted() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isEnchanted@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isFireImmune() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isFireImmune@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isImmobile() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isImmobile@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isInLava() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isInLava@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isInWall() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isInWall@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isInWater() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isInWater@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isInvertedHealAndHarm() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isInvertedHealAndHarm@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isInvisible() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isInvisible@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isInvulnerableTo(class ActorDamageSource const& a0) const{
        bool (Actor::*rv)(class ActorDamageSource const&) const;
        *((void**)&rv) = dlsym("?isInvulnerableTo@Actor@@UEBA_NAEBVActorDamageSource@@@Z");
        return (this->*rv)(std::forward<class ActorDamageSource const&>(a0));
    }
    inline bool isOnFire() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isOnFire@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isOnHotBlock() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isOnHotBlock@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isOverWater() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isOverWater@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isSilent(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?isSilent@Actor@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool isSkyLit(float a0){
        bool (Actor::*rv)(float);
        *((void**)&rv) = dlsym("?isSkyLit@Actor@@UEAA_NM@Z");
        return (this->*rv)(std::forward<float>(a0));
    }
    inline bool isUnderLiquid(int \/*enum enum MaterialType*\/ a0) const{
        bool (Actor::*rv)(int \/*enum enum MaterialType*\/) const;
        *((void**)&rv) = dlsym("?isUnderLiquid@Actor@@UEBA_NW4MaterialType@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum MaterialType*\/>(a0));
    }
    inline bool const isWearingLeatherArmor() const{
        bool const (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?isWearingLeatherArmor@Actor@@UEBA?B_NXZ");
        return (this->*rv)();
    }
    inline void kill(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?kill@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void killed(class Actor& a0){
        void (Actor::*rv)(class Actor&);
        *((void**)&rv) = dlsym("?killed@Actor@@UEAAXAEAV1@@Z");
        return (this->*rv)(std::forward<class Actor&>(a0));
    }
    inline void lerpMotion(class Vec3 const& a0){
        void (Actor::*rv)(class Vec3 const&);
        *((void**)&rv) = dlsym("?lerpMotion@Actor@@UEAAXAEBVVec3@@@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0));
    }
    inline bool load(class CompoundTag const& a0, class DataLoadHelper& a1){
        bool (Actor::*rv)(class CompoundTag const&, class DataLoadHelper&);
        *((void**)&rv) = dlsym("?load@Actor@@UEAA_NAEBVCompoundTag@@AEAVDataLoadHelper@@@Z");
        return (this->*rv)(std::forward<class CompoundTag const&>(a0), std::forward<class DataLoadHelper&>(a1));
    }
    inline void loadLinks(class CompoundTag const& a0, std::vector<struct ActorLink>& a1, class DataLoadHelper& a2){
        void (Actor::*rv)(class CompoundTag const&, std::vector<struct ActorLink>&, class DataLoadHelper&);
        *((void**)&rv) = dlsym("?loadLinks@Actor@@UEAAXAEBVCompoundTag@@AEAV?$vector@UActorLink@@V?$allocator@UActorLink@@@std@@@std@@AEAVDataLoadHelper@@@Z");
        return (this->*rv)(std::forward<class CompoundTag const&>(a0), std::forward<std::vector<struct ActorLink>&>(a1), std::forward<class DataLoadHelper&>(a2));
    }
    inline void markHurt(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?markHurt@Actor@@MEAAXXZ");
        return (this->*rv)();
    }
    inline void move(class Vec3 const& a0){
        void (Actor::*rv)(class Vec3 const&);
        *((void**)&rv) = dlsym("?move@Actor@@UEAAXAEBVVec3@@@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0));
    }
    inline void move(struct IActorMovementProxy& a0, class Vec3 const& a1) const{
        void (Actor::*rv)(struct IActorMovementProxy&, class Vec3 const&) const;
        *((void**)&rv) = dlsym("?move@Actor@@UEBAXAEAUIActorMovementProxy@@AEBVVec3@@@Z");
        return (this->*rv)(std::forward<struct IActorMovementProxy&>(a0), std::forward<class Vec3 const&>(a1));
    }
    inline void normalTick(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?normalTick@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void onAboveBubbleColumn(bool a0){
        void (Actor::*rv)(bool);
        *((void**)&rv) = dlsym("?onAboveBubbleColumn@Actor@@UEAAX_N@Z");
        return (this->*rv)(std::forward<bool>(a0));
    }
    inline void onEffectAdded(class MobEffectInstance& a0){
        void (Actor::*rv)(class MobEffectInstance&);
        *((void**)&rv) = dlsym("?onEffectAdded@Actor@@UEAAXAEAVMobEffectInstance@@@Z");
        return (this->*rv)(std::forward<class MobEffectInstance&>(a0));
    }
    inline void onEffectRemoved(class MobEffectInstance& a0){
        void (Actor::*rv)(class MobEffectInstance&);
        *((void**)&rv) = dlsym("?onEffectRemoved@Actor@@UEAAXAEAVMobEffectInstance@@@Z");
        return (this->*rv)(std::forward<class MobEffectInstance&>(a0));
    }
    inline void onEffectUpdated(class MobEffectInstance& a0){
        void (Actor::*rv)(class MobEffectInstance&);
        *((void**)&rv) = dlsym("?onEffectUpdated@Actor@@UEAAXAEAVMobEffectInstance@@@Z");
        return (this->*rv)(std::forward<class MobEffectInstance&>(a0));
    }
    inline void onInsideBubbleColumn(bool a0){
        void (Actor::*rv)(bool);
        *((void**)&rv) = dlsym("?onInsideBubbleColumn@Actor@@UEAAX_N@Z");
        return (this->*rv)(std::forward<bool>(a0));
    }
    inline void onLightningHit(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?onLightningHit@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void onOrphan(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?onOrphan@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void onSynchedDataUpdate(int a0){
        void (Actor::*rv)(int);
        *((void**)&rv) = dlsym("?onSynchedDataUpdate@Actor@@UEAAXH@Z");
        return (this->*rv)(std::forward<int>(a0));
    }
    inline void onSynchedFlagUpdate(int a0, __int64 a1, __int64 a2){
        void (Actor::*rv)(int, __int64, __int64);
        *((void**)&rv) = dlsym("?onSynchedFlagUpdate@Actor@@UEAAXH_J0@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<__int64>(a1), std::forward<__int64>(a2));
    }
    inline void openContainerComponent(class Player& a0){
        void (Actor::*rv)(class Player&);
        *((void**)&rv) = dlsym("?openContainerComponent@Actor@@UEAAXAEAVPlayer@@@Z");
        return (this->*rv)(std::forward<class Player&>(a0));
    }
    inline void outOfWorld(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?outOfWorld@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void performRangedAttack(class Actor& a0, float a1){
        void (Actor::*rv)(class Actor&, float);
        *((void**)&rv) = dlsym("?performRangedAttack@Actor@@UEAAXAEAV1@M@Z");
        return (this->*rv)(std::forward<class Actor&>(a0), std::forward<float>(a1));
    }
    inline void playAmbientSound(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?playAmbientSound@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void playSynchronizedSound(int \/*enum enum LevelSoundEvent*\/ a0, class Vec3 const& a1, class Block const& a2, bool a3){
        void (Actor::*rv)(int \/*enum enum LevelSoundEvent*\/, class Vec3 const&, class Block const&, bool);
        *((void**)&rv) = dlsym("?playSynchronizedSound@Actor@@UEAAXW4LevelSoundEvent@@AEBVVec3@@AEBVBlock@@_N@Z");
        return (this->*rv)(std::forward<int \/*enum enum LevelSoundEvent*\/>(a0), std::forward<class Vec3 const&>(a1), std::forward<class Block const&>(a2), std::forward<bool>(a3));
    }
    inline void playSynchronizedSound(int \/*enum enum LevelSoundEvent*\/ a0, class Vec3 const& a1, int a2, bool a3){
        void (Actor::*rv)(int \/*enum enum LevelSoundEvent*\/, class Vec3 const&, int, bool);
        *((void**)&rv) = dlsym("?playSynchronizedSound@Actor@@UEAAXW4LevelSoundEvent@@AEBVVec3@@H_N@Z");
        return (this->*rv)(std::forward<int \/*enum enum LevelSoundEvent*\/>(a0), std::forward<class Vec3 const&>(a1), std::forward<int>(a2), std::forward<bool>(a3));
    }
    inline void positionPassenger(class Actor& a0, float a1){
        void (Actor::*rv)(class Actor&, float);
        *((void**)&rv) = dlsym("?positionPassenger@Actor@@UEAAXAEAV1@M@Z");
        return (this->*rv)(std::forward<class Actor&>(a0), std::forward<float>(a1));
    }
    inline void pushOutOfBlocks(class Vec3 const& a0){
        void (Actor::*rv)(class Vec3 const&);
        *((void**)&rv) = dlsym("?pushOutOfBlocks@Actor@@MEAAXAEBVVec3@@@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0));
    }
    inline class HashedString const& queryEntityRenderer() const{
        class HashedString const& (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?queryEntityRenderer@Actor@@UEBAAEBVHashedString@@XZ");
        return (this->*rv)();
    }
    inline void readAdditionalSaveData(class CompoundTag const& a0, class DataLoadHelper& a1){
        void (Actor::*rv)(class CompoundTag const&, class DataLoadHelper&);
        *((void**)&rv) = dlsym("?readAdditionalSaveData@Actor@@MEAAXAEBVCompoundTag@@AEAVDataLoadHelper@@@Z");
        return (this->*rv)(std::forward<class CompoundTag const&>(a0), std::forward<class DataLoadHelper&>(a1));
    }
    inline void reloadComponents(int \/*enum enum Actor::InitializationMethod*\/ a0, class VariantParameterList const& a1){
        void (Actor::*rv)(int \/*enum enum Actor::InitializationMethod*\/, class VariantParameterList const&);
        *((void**)&rv) = dlsym("?reloadComponents@Actor@@MEAAXW4InitializationMethod@1@AEBVVariantParameterList@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum Actor::InitializationMethod*\/>(a0), std::forward<class VariantParameterList const&>(a1));
    }
    inline void reloadHardcodedClient(int \/*enum enum Actor::InitializationMethod*\/ a0, class VariantParameterList const& a1){
        void (Actor::*rv)(int \/*enum enum Actor::InitializationMethod*\/, class VariantParameterList const&);
        *((void**)&rv) = dlsym("?reloadHardcodedClient@Actor@@MEAAXW4InitializationMethod@1@AEBVVariantParameterList@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum Actor::InitializationMethod*\/>(a0), std::forward<class VariantParameterList const&>(a1));
    }
    inline void reloadLootTable(struct EquipmentTableDefinition const& a0){
        void (Actor::*rv)(struct EquipmentTableDefinition const&);
        *((void**)&rv) = dlsym("?reloadLootTable@Actor@@UEAAXAEBUEquipmentTableDefinition@@@Z");
        return (this->*rv)(std::forward<struct EquipmentTableDefinition const&>(a0));
    }
    inline void reloadLootTable(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?reloadLootTable@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void remove(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?remove@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void reset(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?reset@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void resetBlockMovementSlowdownMultiplier(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?resetBlockMovementSlowdownMultiplier@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline bool save(class CompoundTag& a0){
        bool (Actor::*rv)(class CompoundTag&);
        *((void**)&rv) = dlsym("?save@Actor@@UEAA_NAEAVCompoundTag@@@Z");
        return (this->*rv)(std::forward<class CompoundTag&>(a0));
    }
    inline void saveWithoutId(class CompoundTag& a0){
        void (Actor::*rv)(class CompoundTag&);
        *((void**)&rv) = dlsym("?saveWithoutId@Actor@@UEAAXAEAVCompoundTag@@@Z");
        return (this->*rv)(std::forward<class CompoundTag&>(a0));
    }
    inline void sendMotionPacketIfNeeded(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?sendMotionPacketIfNeeded@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void setArmor(int \/*enum enum ArmorSlot*\/ a0, class ItemStack const& a1){
        void (Actor::*rv)(int \/*enum enum ArmorSlot*\/, class ItemStack const&);
        *((void**)&rv) = dlsym("?setArmor@Actor@@UEAAXW4ArmorSlot@@AEBVItemStack@@@Z");
        return (this->*rv)(std::forward<int \/*enum enum ArmorSlot*\/>(a0), std::forward<class ItemStack const&>(a1));
    }
    inline void setBlockMovementSlowdownMultiplier(class Vec3 const& a0){
        void (Actor::*rv)(class Vec3 const&);
        *((void**)&rv) = dlsym("?setBlockMovementSlowdownMultiplier@Actor@@UEAAXAEBVVec3@@@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0));
    }
    inline void setCanPowerJump(bool a0){
        void (Actor::*rv)(bool);
        *((void**)&rv) = dlsym("?setCanPowerJump@Actor@@UEAAX_N@Z");
        return (this->*rv)(std::forward<bool>(a0));
    }
    inline void setCarriedItem(class ItemStack const& a0){
        void (Actor::*rv)(class ItemStack const&);
        *((void**)&rv) = dlsym("?setCarriedItem@Actor@@UEAAXAEBVItemStack@@@Z");
        return (this->*rv)(std::forward<class ItemStack const&>(a0));
    }
    inline void setDamageNearbyMobs(bool a0){
        void (Actor::*rv)(bool);
        *((void**)&rv) = dlsym("?setDamageNearbyMobs@Actor@@UEAAX_N@Z");
        return (this->*rv)(std::forward<bool>(a0));
    }
    inline void setLastHurtByMob(class Mob* a0){
        void (Actor::*rv)(class Mob*);
        *((void**)&rv) = dlsym("?setLastHurtByMob@Actor@@UEAAXPEAVMob@@@Z");
        return (this->*rv)(std::forward<class Mob*>(a0));
    }
    inline void setLastHurtByPlayer(class Player* a0){
        void (Actor::*rv)(class Player*);
        *((void**)&rv) = dlsym("?setLastHurtByPlayer@Actor@@UEAAXPEAVPlayer@@@Z");
        return (this->*rv)(std::forward<class Player*>(a0));
    }
    inline void setLastHurtMob(class Actor* a0){
        void (Actor::*rv)(class Actor*);
        *((void**)&rv) = dlsym("?setLastHurtMob@Actor@@UEAAXPEAV1@@Z");
        return (this->*rv)(std::forward<class Actor*>(a0));
    }
    inline void setNameTag(std::string const& a0){
        void (Actor::*rv)(std::string const&);
        *((void**)&rv) = dlsym("?setNameTag@Actor@@UEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline void setNameTagVisible(bool a0){
        void (Actor::*rv)(bool);
        *((void**)&rv) = dlsym("?setNameTagVisible@Actor@@UEAAX_N@Z");
        return (this->*rv)(std::forward<bool>(a0));
    }
    inline void setOffhandSlot(class ItemStack const& a0){
        void (Actor::*rv)(class ItemStack const&);
        *((void**)&rv) = dlsym("?setOffhandSlot@Actor@@UEAAXAEBVItemStack@@@Z");
        return (this->*rv)(std::forward<class ItemStack const&>(a0));
    }
    inline void setOwner(struct ActorUniqueID a0){
        void (Actor::*rv)(struct ActorUniqueID);
        *((void**)&rv) = dlsym("?setOwner@Actor@@UEAAXUActorUniqueID@@@Z");
        return (this->*rv)(std::forward<struct ActorUniqueID>(a0));
    }
    inline void setPos(class Vec3 const& a0){
        void (Actor::*rv)(class Vec3 const&);
        *((void**)&rv) = dlsym("?setPos@Actor@@UEAAXAEBVVec3@@@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0));
    }
    inline void setRot(class Vec2 const& a0){
        void (Actor::*rv)(class Vec2 const&);
        *((void**)&rv) = dlsym("?setRot@Actor@@UEAAXAEBVVec2@@@Z");
        return (this->*rv)(std::forward<class Vec2 const&>(a0));
    }
    inline void setScoreTag(std::string const& a0){
        void (Actor::*rv)(std::string const&);
        *((void**)&rv) = dlsym("?setScoreTag@Actor@@UEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline void setSitting(bool a0){
        void (Actor::*rv)(bool);
        *((void**)&rv) = dlsym("?setSitting@Actor@@UEAAX_N@Z");
        return (this->*rv)(std::forward<bool>(a0));
    }
    inline void setSize(float a0, float a1){
        void (Actor::*rv)(float, float);
        *((void**)&rv) = dlsym("?setSize@Actor@@UEAAXMM@Z");
        return (this->*rv)(std::forward<float>(a0), std::forward<float>(a1));
    }
    inline void setSneaking(bool a0){
        void (Actor::*rv)(bool);
        *((void**)&rv) = dlsym("?setSneaking@Actor@@UEAAX_N@Z");
        return (this->*rv)(std::forward<bool>(a0));
    }
    inline void setStanding(bool a0){
        void (Actor::*rv)(bool);
        *((void**)&rv) = dlsym("?setStanding@Actor@@UEAAX_N@Z");
        return (this->*rv)(std::forward<bool>(a0));
    }
    inline void setTarget(class Actor* a0){
        void (Actor::*rv)(class Actor*);
        *((void**)&rv) = dlsym("?setTarget@Actor@@UEAAXPEAV1@@Z");
        return (this->*rv)(std::forward<class Actor*>(a0));
    }
    inline bool shouldDropDeathLoot() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?shouldDropDeathLoot@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool shouldRender() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?shouldRender@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool shouldTick() const{
        bool (Actor::*rv)() const;
        *((void**)&rv) = dlsym("?shouldTick@Actor@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool shouldTryMakeStepSound(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?shouldTryMakeStepSound@Actor@@MEAA_NXZ");
        return (this->*rv)();
    }
    inline class ItemActor* spawnAtLocation(class Block const& a0, int a1){
        class ItemActor* (Actor::*rv)(class Block const&, int);
        *((void**)&rv) = dlsym("?spawnAtLocation@Actor@@UEAAPEAVItemActor@@AEBVBlock@@H@Z");
        return (this->*rv)(std::forward<class Block const&>(a0), std::forward<int>(a1));
    }
    inline class ItemActor* spawnAtLocation(class Block const& a0, int a1, float a2){
        class ItemActor* (Actor::*rv)(class Block const&, int, float);
        *((void**)&rv) = dlsym("?spawnAtLocation@Actor@@UEAAPEAVItemActor@@AEBVBlock@@HM@Z");
        return (this->*rv)(std::forward<class Block const&>(a0), std::forward<int>(a1), std::forward<float>(a2));
    }
    inline class ItemActor* spawnAtLocation(class ItemStack const& a0, float a1){
        class ItemActor* (Actor::*rv)(class ItemStack const&, float);
        *((void**)&rv) = dlsym("?spawnAtLocation@Actor@@UEAAPEAVItemActor@@AEBVItemStack@@M@Z");
        return (this->*rv)(std::forward<class ItemStack const&>(a0), std::forward<float>(a1));
    }
    inline class ItemActor* spawnAtLocation(int a0, int a1){
        class ItemActor* (Actor::*rv)(int, int);
        *((void**)&rv) = dlsym("?spawnAtLocation@Actor@@UEAAPEAVItemActor@@HH@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<int>(a1));
    }
    inline class ItemActor* spawnAtLocation(int a0, int a1, float a2){
        class ItemActor* (Actor::*rv)(int, int, float);
        *((void**)&rv) = dlsym("?spawnAtLocation@Actor@@UEAAPEAVItemActor@@HHM@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<int>(a1), std::forward<float>(a2));
    }
    inline void spawnTrailBubbles(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?spawnTrailBubbles@Actor@@MEAAXXZ");
        return (this->*rv)();
    }
    inline bool startRiding(class Actor& a0){
        bool (Actor::*rv)(class Actor&);
        *((void**)&rv) = dlsym("?startRiding@Actor@@UEAA_NAEAV1@@Z");
        return (this->*rv)(std::forward<class Actor&>(a0));
    }
    inline void startSpinAttack(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?startSpinAttack@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void startSwimming(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?startSwimming@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void stopRiding(bool a0, bool a1, bool a2){
        void (Actor::*rv)(bool, bool, bool);
        *((void**)&rv) = dlsym("?stopRiding@Actor@@UEAAX_N00@Z");
        return (this->*rv)(std::forward<bool>(a0), std::forward<bool>(a1), std::forward<bool>(a2));
    }
    inline void stopSwimming(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?stopSwimming@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void teleportTo(class Vec3 const& a0, bool a1, int a2, int a3){
        void (Actor::*rv)(class Vec3 const&, bool, int, int);
        *((void**)&rv) = dlsym("?teleportTo@Actor@@UEAAXAEBVVec3@@_NHH@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0), std::forward<bool>(a1), std::forward<int>(a2), std::forward<int>(a3));
    }
    inline void thawFreezeEffect(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?thawFreezeEffect@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void tickLeash(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?tickLeash@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline std::unique_ptr<class AddActorBasePacket> tryCreateAddActorPacket(){
        std::unique_ptr<class AddActorBasePacket> (Actor::*rv)();
        *((void**)&rv) = dlsym("?tryCreateAddActorPacket@Actor@@UEAA?AV?$unique_ptr@VAddActorBasePacket@@U?$default_delete@VAddActorBasePacket@@@std@@@std@@XZ");
        return (this->*rv)();
    }
    inline bool tryTeleportTo(class Vec3 const& a0, bool a1, bool a2, int a3, int a4){
        bool (Actor::*rv)(class Vec3 const&, bool, bool, int, int);
        *((void**)&rv) = dlsym("?tryTeleportTo@Actor@@UEAA_NAEBVVec3@@_N1HH@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0), std::forward<bool>(a1), std::forward<bool>(a2), std::forward<int>(a3), std::forward<int>(a4));
    }
    inline void updateEntityInside(class AABB const& a0){
        void (Actor::*rv)(class AABB const&);
        *((void**)&rv) = dlsym("?updateEntityInside@Actor@@UEAAXAEBVAABB@@@Z");
        return (this->*rv)(std::forward<class AABB const&>(a0));
    }
    inline void updateEntityInside(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?updateEntityInside@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void updateInsideBlock(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?updateInsideBlock@Actor@@MEAAXXZ");
        return (this->*rv)();
    }
    inline bool updateWaterState(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?updateWaterState@Actor@@MEAA_NXZ");
        return (this->*rv)();
    }
    inline void useItem(class ItemStackBase& a0, int \/*enum enum ItemUseMethod*\/ a1, bool a2){
        void (Actor::*rv)(class ItemStackBase&, int \/*enum enum ItemUseMethod*\/, bool);
        *((void**)&rv) = dlsym("?useItem@Actor@@UEAAXAEAVItemStackBase@@W4ItemUseMethod@@_N@Z");
        return (this->*rv)(std::forward<class ItemStackBase&>(a0), std::forward<int \/*enum enum ItemUseMethod*\/>(a1), std::forward<bool>(a2));
    }
    inline void vehicleTick(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?vehicleTick@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    inline bool wasHurt(){
        bool (Actor::*rv)();
        *((void**)&rv) = dlsym("?wasHurt@Actor@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline void wobble(){
        void (Actor::*rv)();
        *((void**)&rv) = dlsym("?wobble@Actor@@UEAAXXZ");
        return (this->*rv)();
    }
    */
    MCAPI class Vec3 _randomHeartPos();
    MCAPI void _sendDirtyActorData();
    MCAPI void _setActorTypeId(enum ActorType);
    MCAPI void _setLevelPtr(class Level*);
    MCAPI void addDefinitionGroup(std::string const&);
    MCAPI void addEffect(class MobEffectInstance const&);
    MCAPI bool addTag(std::string const&);
    MCAPI void buildDebugGroupInfo(std::string&) const;
    MCAPI class Vec3 buildForward() const;
    MCAPI void burn(int, bool);
    MCAPI void cacheComponentData();
    MCAPI class Vec3 calcCenterPos() const;
    MCAPI int calculateAttackDamage(class Actor&);
    MCAPI bool canAscendCurrentBlockByJumping() const;
    MCAPI bool canBeginOrContinueClimbingLadder() const;
    MCAPI bool canCurrentlySwim() const;
    MCAPI bool canDescendBlockBelowByCrouching() const;
    MCAPI bool canFly() const;
    MCAPI bool canMate(class Actor const&) const;
    MCAPI void celebrateHunt(int, bool);
    MCAPI void clearFishingHookID();
    MCAPI void consumeItem(class ItemActor&, int);
    MCAPI class UpdateEquipPacket createUpdateEquipPacket(int);
    MCAPI class UpdateTradePacket createUpdateTradePacket(int);
    MCAPI void deregisterTagsFromLevelCache();
    MCAPI float distanceSqrToBlockPosCenter(class BlockPos const&) const;
    MCAPI float distanceTo(class Actor const&) const;
    MCAPI float distanceTo(class Vec3 const&) const;
    MCAPI float distanceToSqr(class Actor const&) const;
    MCAPI float distanceToSqr(class Vec3 const&) const;
    MCAPI void dropLeash(bool, bool);
    MCAPI void dropTowards(class ItemStack const&, class Vec3);
    MCAPI bool executeEvent(std::string const&, class VariantParameterList const&);
    MCAPI void exitVehicle(class Actor const&, class std::optional<class Vec3> (*)(struct VehicleUtils::VehicleDirections const&, class std::function<bool (class Vec3 const&, class Vec3 const&)>));
    MCAPI class FishingHook* fetchFishingHook();
    MCAPI std::vector<struct DistanceSortedActor> fetchNearbyActorsSorted(class Vec3 const&, enum ActorType);
    MCAPI void forEachLeashedActor(class std::function<void (class gsl::not_null<class Actor*>)>);
    MCAPI class AABBShapeComponent const& getAABBShapeComponent() const;
    MCAPI int getActiveEffectCount() const;
    MCAPI struct ActorDefinitionIdentifier const& getActorIdentifier() const;
    MCAPI std::vector<class MobEffectInstance> const& getAllEffects() const;
    MCAPI class SimpleContainer& getArmorContainer();
    MCAPI class SimpleContainer const& getArmorContainer() const;
    MCAPI class gsl::not_null<class BaseAttributeMap*> getAttributes();
    MCAPI class BlockPos getBlockPosCurrentlyStandingOn(class Actor*) const;
    MCAPI class BlockPos getBlockTarget() const;
    MCAPI bool getCanPickupItems() const;
    MCAPI class ItemStack const& getCarriedItemInSlotPreferredBy(class ItemStack const&) const;
    MCAPI bool getChainedDamageEffects() const;
    MCAPI bool getCollidableMobNear();
    MCAPI enum PaletteColor getColor() const;
    MCAPI enum PaletteColor getColor2() const;
    MCAPI int getControllingSeat();
    MCAPI float getCurrentSwimAmount() const;
    MCAPI bool getDamageNearbyMobs() const;
    MCAPI class ActorDefinitionDiffList* getDiffList();
    MCAPI class Dimension& getDimension() const;
    MCAPI class Dimension const& getDimensionConst() const;
    MCAPI class EconomyTradeableComponent* getEconomyTradeableComponent() const;
    MCAPI class MobEffectInstance const* getEffect(class MobEffect const&) const;
    MCAPI class SynchedActorData& getEntityData();
    MCAPI class SynchedActorData const& getEntityData() const;
    MCAPI class ActorTerrainInterlockData& getEntityTerrainInterlockData();
    MCAPI enum EquipmentSlot getEquipmentSlotForItem(class ItemStack const&) const;
    MCAPI bool getFirstAvailableSeatPos(class Actor&, class Vec3&) const;
    MCAPI class Actor* getFirstPassenger() const;
    MCAPI class SimpleContainer const& getHandContainer() const;
    MCAPI class SimpleContainer& getHandContainer();
    MCAPI int getHealth() const;
    MCAPI int getHurtDir() const;
    MCAPI int getHurtTime() const;
    MCAPI enum Actor::InitializationMethod getInitializationMethod();
    MCAPI class Vec3 getInterpolatedPosition(float) const;
    MCAPI class Vec2 getInterpolatedRotation(float) const;
    MCAPI int getJumpDuration() const;
    MCAPI int getLastHurtByMobTime();
    MCAPI int getLastHurtByMobTimestamp();
    MCAPI enum ActorDamageCause getLastHurtCause() const;
    MCAPI int getLastHurtDamage() const;
    MCAPI int getLastHurtMobTimestamp();
    MCAPI unsigned __int64 getLastHurtTimestamp() const;
    MCAPI struct ActorUniqueID getLeashHolder() const;
    MCAPI class Level const& getLevel() const;
    MCAPI class Level& getLevel();
    MCAPI int getLimitedLifetimeTicks() const;
    MCAPI std::vector<struct ActorLink> getLinks() const;
    MCAPI int getMarkVariant() const;
    MCAPI int getMaxHealth() const;
    MCAPI class MolangVariableMap& getMolangVariables();
    MCAPI class gsl::not_null<class std::shared_ptr<struct IActorMovementProxy> > getMovementProxy();
    MCAPI class gsl::not_null<class std::shared_ptr<struct IActorMovementProxy const> > getMovementProxy() const;
    MCAPI class ItemStack const& getOffhandSlot() const;
    MCAPI class Mob* getOwner() const;
    MCAPI struct ActorUniqueID const getOwnerId() const;
    MCAPI int getPassengerIndex(class Actor const&) const;
    MCAPI std::unique_ptr<class CompoundTag> getPersistingTradeOffers();
    MCAPI int getPersistingTradeRiches();
    MCAPI class Player* getPlayerOwner() const;
    MCAPI enum PortalAxis getPortalEntranceAxis() const;
    MCAPI class Vec3 const& getPostTickPosDelta() const;
    MCAPI float getRadius() const;
    MCAPI class Random& getRandom() const;
    MCAPI class BlockSource& getRegion() const;
    MCAPI class BlockSource const& getRegionConst() const;
    MCAPI class RenderParams& getRenderParams();
    MCAPI class Vec2 getRotation() const;
    MCAPI class ActorRuntimeID getRuntimeID() const;
    MCAPI int getShakeTime() const;
    MCAPI int getSkinID() const;
    MCAPI class SpatialActorNetworkData& getSpatialNetworkData();
    MCAPI class SpatialActorNetworkData const& getSpatialNetworkData() const;
    MCAPI float getSpeedInMetersPerSecond() const;
    MCAPI class StateVectorComponent const& getStateVectorComponent() const;
    MCAPI class StateVectorComponent& getStateVectorComponentNonConst();
    MCAPI bool getStatusFlag(enum ActorFlags) const;
    MCAPI int getStrength() const;
    MCAPI int getStrengthMax() const;
    MCAPI int getStructuralIntegrity() const;
    MCAPI float getSwimAmount(float) const;
    MCAPI class gsl::span<std::string, -1> const getTags() const;
    MCAPI class Actor* getTarget() const;
    MCAPI struct ActorUniqueID getTargetId();
    MCAPI class ITickingArea* getTickingArea();
    MCAPI bool getTradeInterest() const;
    MCAPI class MerchantRecipeList* getTradeOffers();
    MCAPI class Player* getTradingPlayer() const;
    MCAPI struct ActorUniqueID const& getUniqueID() const;
    MCAPI int getVariant() const;
    MCAPI class Actor* getVehicle() const;
    MCAPI class Actor* getVehicleRoot() const;
    MCAPI class ActorRuntimeID getVehicleRuntimeID() const;
    MCAPI float getVerticalSpeedInMetersPerSecond() const;
    MCAPI class Vec3 getViewVector(float) const;
    MCAPI bool hasAnyEffects() const;
    MCAPI bool hasAnyVisibleEffects() const;
    MCAPI bool hasBeenHurtByMobInLastTicks(int) const;
    MCAPI bool hasCategory(enum ActorCategory) const;
    MCAPI bool hasDefinitionGroup(std::string const&) const;
    MCAPI bool hasDimension() const;
    MCAPI bool hasEffect(class MobEffect const&) const;
    MCAPI bool hasFamily(class HashedString const&) const;
    MCAPI bool hasFishingHook() const;
    MCAPI bool hasLevel() const;
    MCAPI bool hasPassenger() const;
    MCAPI bool hasPersistingTrade() const;
    MCAPI bool hasPlayerPassenger() const;
    MCAPI bool hasPriorityAmmunition() const;
    MCAPI bool hasRuntimeID() const;
    MCAPI bool hasSaddle() const;
    MCAPI bool hasTag(std::string const&) const;
    MCAPI bool hasTags() const;
    MCAPI bool hasTeleported() const;
    MCAPI bool hasTickingArea() const;
    MCAPI bool hasTotemEquipped() const;
    MCAPI bool hasType(enum ActorType) const;
    MCAPI bool hasUniqueID() const;
    MCAPI void healEffects(int);
    MCAPI bool hurt(class ActorDamageSource const&, int, bool, bool);
    MCAPI bool inDownwardFlowingLiquid() const;
    MCAPI void initActorProperties();
    MCAPI void initParams(class VariantParameterList&);
    MCAPI bool isActorLocationInMaterial(enum ActorLocation, enum MaterialType) const;
    MCAPI bool isAngry() const;
    MCAPI bool isAutonomous() const;
    MCAPI bool isBaby() const;
    MCAPI bool isBreakingObstruction() const;
    MCAPI bool isBribed() const;
    MCAPI bool isCharged() const;
    MCAPI bool isChested() const;
    MCAPI bool isClimbing() const;
    MCAPI bool isControlledByLocalInstance() const;
    MCAPI bool isDoorBreaker() const;
    MCAPI bool isDoorOpener() const;
    MCAPI bool isGlobal() const;
    MCAPI bool isIgnited() const;
    MCAPI bool isImmersedInWater() const;
    MCAPI bool isInClouds() const;
    MCAPI bool isInContactWithWater() const;
    MCAPI bool isInLove() const;
    MCAPI bool isInPrecipitation() const;
    MCAPI bool isInRain() const;
    MCAPI bool isInScaffolding() const;
    MCAPI bool isInSnow() const;
    MCAPI bool isInThunderstorm() const;
    MCAPI bool isInWaterOrRain() const;
    MCAPI bool isInWorld() const;
    MCAPI bool isInsideBorderBlock(float) const;
    MCAPI bool isInsidePortal() const;
    MCAPI bool isLayingDown() const;
    MCAPI bool isLeashed() const;
    MCAPI bool isMovedToLimbo() const;
    MCAPI bool isMoving() const;
    MCAPI bool isOrphan() const;
    MCAPI bool isOutOfControl() const;
    MCAPI bool isOverScaffolding() const;
    MCAPI bool isPacified() const;
    MCAPI bool isPassenger(struct ActorUniqueID const&) const;
    MCAPI bool isPassenger(class Actor const&) const;
    MCAPI bool isPersistent() const;
    MCAPI bool isPlayingDead() const;
    MCAPI bool isPowered() const;
    MCAPI bool isRegionValid() const;
    MCAPI bool isRemoved() const;
    MCAPI bool isResting() const;
    MCAPI bool isRiding(class Actor*) const;
    MCAPI bool isRiding() const;
    MCAPI bool isSafeToSleepNear() const;
    MCAPI bool isSheared() const;
    MCAPI bool isSitting() const;
    MCAPI bool isSneaking() const;
    MCAPI bool isStackable() const;
    MCAPI bool isStanding() const;
    MCAPI bool isSwimmer() const;
    MCAPI bool isSwimming() const;
    MCAPI bool isTame() const;
    MCAPI bool isTickingEntity() const;
    MCAPI bool isTrading() const;
    MCAPI bool isTrusting() const;
    MCAPI bool isType(enum ActorType) const;
    MCAPI bool isWASDControlled();
    MCAPI bool isWalker() const;
    MCAPI void lerpTo(class Vec3 const&, class Vec2 const&, int);
    MCAPI void lerpTo(class Vec3 const&, class Vec2 const&, float, int);
    MCAPI void lerpToRotation(class Vec2 const&, int);
    MCAPI void loadEntityFlags(class CompoundTag const&, class DataLoadHelper&);
    MCAPI struct ActorUniqueID const& lovePartnerId() const;
    MCAPI void migrateUniqueID(struct ActorUniqueID);
    MCAPI void moveBBs(class Vec3 const&);
    MCAPI void moveRelative(float, float, float, float);
    MCAPI void moveTo(class Vec3 const&, class Vec2 const&);
    MCAPI void onAffectedByWaterBottle();
    MCAPI bool onClimbableBlock() const;
    MCAPI bool onHoverableBlock() const;
    MCAPI void onOnewayCollision(class AABB const&);
    MCAPI bool operator==(class Actor&);
    MCAPI void pickUpItem(class ItemActor&, int);
    MCAPI void playSound(enum LevelSoundEvent, class Vec3 const&, class Block const&);
    MCAPI void playSound(enum LevelSoundEvent, class Vec3 const&, int);
    MCAPI void positionAllPassengers();
    MCAPI bool pullInEntity(class Actor&);
    MCAPI void pushBackActionEventToActionQueue(class ActionEvent);
    MCAPI void refreshComponents();
    MCAPI void reload();
    MCAPI void reloadProperties();
    MCAPI void removeAllEffects();
    MCAPI void removeAllPassengers(bool, bool);
    MCAPI void removeEffect(int);
    MCAPI void removeEffectParticles();
    MCAPI void removePersistingTrade();
    MCAPI bool removeTag(std::string const&);
    MCAPI void resetClientAnimations();
    MCAPI void resetRegion();
    MCAPI void saveEntityFlags(class CompoundTag&);
    MCAPI std::unique_ptr<class ListTag> saveLinks() const;
    MCAPI void savePersistingTrade(std::unique_ptr<class CompoundTag>, int);
    MCAPI void sendActorDefinitionEventTriggered(std::string const&);
    MCAPI void sendMotionToServer();
    MCAPI void serializationSetHealth(int);
    MCAPI void setAABB(class AABB const&);
    MCAPI void setAABBDim(class Vec2 const&);
    MCAPI void setActorRendererId(class HashedString);
    MCAPI void setAutonomous(bool);
    MCAPI void setBaseDefinition(struct ActorDefinitionIdentifier const&, bool, bool);
    MCAPI void setBlockTarget(class BlockPos const&);
    MCAPI void setBreakingObstruction(bool);
    MCAPI void setCanClimb(bool);
    MCAPI void setCanFly(bool);
    MCAPI void setChainedDamageEffects(bool);
    MCAPI void setCharged(bool);
    MCAPI void setClimbing(bool);
    MCAPI void setCollidableMob(bool);
    MCAPI void setCollidableMobNear(bool);
    MCAPI void setColor(enum PaletteColor);
    MCAPI void setColor2(enum PaletteColor);
    MCAPI void setDancing(bool);
    MCAPI void setDoorBreaker(bool);
    MCAPI void setDoorOpener(bool);
    MCAPI void setEnchanted(bool);
    MCAPI void setFishingHookID(struct ActorUniqueID);
    MCAPI void setGlobal(bool);
    MCAPI void setHurtDir(int);
    MCAPI void setHurtTime(int);
    MCAPI void setInLove(class Actor*);
    MCAPI void setInterpolation(bool);
    MCAPI void setInvisible(bool);
    MCAPI void setJumpDuration(int);
    MCAPI void setLastHitBB(class Vec3 const&, class Vec3 const&);
    MCAPI void setLayingDown(bool);
    MCAPI void setLeashHolder(struct ActorUniqueID);
    MCAPI void setLimitedLifetimeTicks(int);
    MCAPI void setMarkVariant(int);
    MCAPI void setMovedToLimbo(bool);
    MCAPI void setMoving(bool);
    MCAPI void setPersistent();
    MCAPI void setPosDirectLegacy(class Vec3 const&);
    MCAPI void setPosPrev(class Vec3 const&);
    MCAPI void setPreviousPosRot(class Vec3 const&, class Vec2 const&);
    MCAPI void setRegion(class BlockSource&);
    MCAPI void setResting(bool);
    MCAPI void setRuntimeID(class ActorRuntimeID);
    MCAPI void setSaddle(bool);
    MCAPI void setScared(bool);
    MCAPI void setSeatDescription(class Vec3 const&, struct SeatDescription const&);
    MCAPI void setShakeTime(int);
    MCAPI void setSkinID(int);
    MCAPI bool setStatusFlag(enum ActorFlags, bool);
    MCAPI void setStrength(int);
    MCAPI void setStrengthMax(int);
    MCAPI void setStructuralIntegrity(int);
    MCAPI void setStunned(bool);
    MCAPI void setSwimmer(bool);
    MCAPI void setTempted(bool);
    MCAPI void setTradeInterest(bool);
    MCAPI void setTradingPlayer(class Player*);
    MCAPI void setUniqueID(struct ActorUniqueID);
    MCAPI void setVariant(int);
    MCAPI void setWASDControlled(bool);
    MCAPI void setWalker(bool);
    MCAPI bool shouldOrphan(class BlockSource&);
    MCAPI bool shouldUpdateEffects() const;
    MCAPI void spawnBalloonPopParticles();
    MCAPI void spawnDeathParticles();
    MCAPI void spawnDustParticles(int);
    MCAPI void spawnEatParticles(class ItemStack const&, int);
    MCAPI void spawnTamingParticles(bool);
    MCAPI void teleportPassengersTo(class Vec3 const&, int, int);
    MCAPI void testForEntityStacking(class BlockSource&, class AABB const&, std::vector<class AABB>&);
    MCAPI bool tick(class BlockSource&);
    MCAPI void tickBlockDamage();
    MCAPI void transferTickingArea(class Dimension&);
    MCAPI std::vector<class ItemDescriptor> const* tryGetEquippableSlotAllowedItems(int) const;
    MCAPI bool tryMoveChunks();
    MCAPI void updateBBFromDefinition();
    MCAPI void updateDescription();
    MCAPI void updateInvisibilityStatus();
    MCAPI void updateMolangVariables(class RenderParams&);
    MCAPI void updateTickingData();
    MCAPI bool useSaddle(class ItemStackBase&, class Player*);
    MCAPI bool wasLastHitByPlayer();
    MCAPI bool wasLoadedFromNBTThisFrame() const;
    MCAPI static float const DEFAULT_AMBIENT_SOUND_INTERVAL;
    MCAPI static float const DEFAULT_AMBIENT_SOUND_INTERVAL_RANGE;
    MCAPI static class Vec3 const LAVA_AABB_SHRINK_AMOUNT;
    MCAPI static float const LAVA_FLOW_STRENGTH_MULTIPLIER;
    MCAPI static int const MAX_BYTE_CHARGE_AMOUNT;
    MCAPI static std::string const RIDING_TAG;
    MCAPI static int const TOTAL_AIR_SUPPLY;
    MCAPI static class Vec3 const WATER_AABB_SHRINK_AMOUNT;
    MCAPI static float const WATER_FLOW_STRENGTH_MULTIPLIER;
    MCAPI static void _move(struct IActorMovementProxy&, class Vec3 const&);
    MCAPI static class Vec3 buildForward(struct IActorMovementProxy const&);
    MCAPI static bool canBeginOrContinueClimbingLadder(struct IActorMovementProxy const&);
    MCAPI static void checkEntityOnewayCollision(class BlockSource&, class BlockPos const&);
    MCAPI static class BlockPos getBlockPosCurrentlyStandingOn(struct IActorMovementProxy const&, struct IActorMovementProxy*);
    MCAPI static class Vec2 getInterpolatedRotation(class Vec2 const&, class Vec2 const&, float);
    MCAPI static class AABB getLiquidAABB(struct IActorMovementProxy const&, enum MaterialType);
    MCAPI static float getLiquidFlowStrength(enum MaterialType);
    MCAPI static bool getStatusFlag(class SynchedActorData const&, enum ActorFlags);
    MCAPI static class Vec3 getViewVector(struct IActorMovementProxy const&, float);
    MCAPI static class Vec3 getViewVector(class Vec2 const&, class Vec2 const&, float);
    MCAPI static bool hasSubBBIn(struct IActorMovementProxy const&, enum MaterialType);
    MCAPI static bool isFree(struct IActorMovementProxy&, class Vec3 const&, float);
    MCAPI static bool isImmersedInWater(struct IActorMovementProxy const&);
    MCAPI static bool isImmobile(struct IActorMovementProxy const&);
    MCAPI static bool isInScaffolding(struct IActorMovementProxy const&);
    MCAPI static bool isSitting(struct IActorMovementProxy const&);
    MCAPI static bool isStanding(struct IActorMovementProxy const&);
    MCAPI static void moveRelative(struct IActorMovementProxy&, float, float, float, float);
    MCAPI static bool onClimbableBlock(struct IActorMovementProxy const&);
    MCAPI static bool setStatusFlag(class SynchedActorData&, enum ActorFlags, bool);
    MCAPI static void testForCollidableMobs(struct IActorMovementProxy const&, class BlockSource&, class AABB const&, std::vector<class AABB>&);
    MCAPI static class Actor* tryGetFromEntity(class EntityContext&, bool);
    MCAPI static class Actor* tryGetFromEntity(class OwnerPtrT<struct EntityRefTraits> const&, bool);

protected:
    MCAPI bool _damageSensorComponentHurt(int&, int, class ActorDamageSource const&);
    MCAPI class ItemActor const* _drop(class ItemStack const&, bool);
    MCAPI class AABBShapeComponent& _getAABBShapeComponentNonConst();
    MCAPI bool _isHeadInWater() const;
    MCAPI void _playMovementSound(bool);
    MCAPI void _refreshAABB();
    MCAPI void _setAABBDim(class Vec2 const&);
    MCAPI void _setArmorContainer(std::unique_ptr<class SimpleContainer>);
    MCAPI void _setHandContainer(std::unique_ptr<class SimpleContainer>);
    MCAPI void _setHeightOffset(float);
    MCAPI void _setNetherPortalData(class AutomaticID<class Dimension, int>, class AutomaticID<class Dimension, int>, int);
    MCAPI void _setPos(class Vec3 const&);
    MCAPI void _setPosPrev(class Vec3 const&);
    MCAPI void enableAutoSendPosRot(bool);
    MCAPI static int const PLAYER_HURT_EXPERIENCE_TIME;
    MCAPI static class Block const& getBlockWhenClimbing(struct IActorMovementProxy const&);

private:
    MCAPI void _initAliasProperties();
    MCAPI void _initializeLeashRopeSystem();
    MCAPI void _managePassengers(class BlockSource&);
    MCAPI void _moveHitboxTo(class Vec3 const&);
    MCAPI void _sendLinkPacket(struct ActorLink const&) const;
    MCAPI void _serializeComponents(class CompoundTag&);
    MCAPI void _setupServerAnimationComponent();
    MCAPI void _spawnTreasureHuntingParticles();
    MCAPI bool _tryPlaceAt(class Vec3 const&, class AABB const&);
    MCAPI void _tryPlantWitherRose();
    MCAPI void _updateComposition(bool);
    MCAPI void _updateOwnerChunk();
    MCAPI static int const DAMAGE_NEARBY_MOBS_DURATION;
    MCAPI static float const DEFAULT_MAX_DISTANCE_OPTIMIZATION;
    MCAPI static unsigned __int64 const DEFAULT_MAX_TICK_DELAY_OPTIMIZATION;
    MCAPI static bool _containsSneakCollisionShapes(struct IActorMovementProxy&, class AABB const&);
};